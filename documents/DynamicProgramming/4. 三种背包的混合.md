# 背包九讲（四） —— 三种背包的混合

## 题目描述
在实际问题中，经常会遇到同时包含三种不同类型物品的背包问题：
- 01背包类物品：每件物品只能选一次
- 完全背包类物品：每件物品可以选无限次
- 多重背包类物品：每件物品最多选 $s[i]$ 次

求解这类混合背包问题，关键在于理解三种基本背包的本质差异，并在处理每个物品时，根据其类型选择合适的处理方式。

---

## 三类背包问题的核心对比

### 顺序与优化对比表

| 问题类型 | 内层容量遍历顺序    | 内部条件/循环                   | 一维优化代码核心                                                                                                                |
| -------- | ------------------- | ------------------------------- | ------------------------------------------------------------------------------------------------------------------------------- |
| 01背包   | 倒序 (j = v → c[i]) | 只允许每个物品用一次            | for (int j = v; j >= c[i]; j--)<br>dp[j] = max(dp[j], dp[j-c[i]] + w[i]);                                                       |
| 完全背包 | 正序 (j = c[i] → v) | 每个物品可用无限次              | for (int j = c[i]; j <= v; j++)<br>dp[j] = max(dp[j], dp[j-c[i]] + w[i]);                                                       |
| 多重背包 | 倒序 (j = v → c[i]) | 每个物品最多用 s[i] 次，需枚举k | for (int j = v; j >= c[i]; j--)<br>for (int k = 0; k <= s[i] && j >= k*c[i]; k++)<br>dp[j] = max(dp[j], dp[j-k*c[i]] + k*w[i]); |

### 核心差异说明
- **01背包**：倒序遍历容量，防止同一物品被多次选取。因为倒序时 $dp[j-c[i]]$ 是上一轮的旧值。
- **完全背包**：正序遍历容量，允许同一物品被多次选取。因为正序时 $dp[j-c[i]]$ 可能是本轮已更新的值。
- **多重背包**：倒序遍历容量，并在内部枚举每种可选件数k，保证不超过最大件数限制 $s[i]$。

---

## 混合背包问题的解法

### 基本思路
混合背包问题的本质是**分类型处理**：
1. 遍历每个物品
2. 判断物品类型（01背包、完全背包、多重背包）
3. 根据类型调用相应的处理方式
4. 更新 dp 数组

### 代码实现（朴素版）

```java
class Solution {
    /**
     * @param v 背包空间
     * @param c 物品的体积
     * @param w 物品的价值
     * @param type 物品类型：0-01背包，1-完全背包，2-多重背包
     * @param s 多重背包的件数限制
     * @return 最大价值
     */
    public static int solute(int v, int[] c, int[] w, int[] type, int[] s) {
        int n = w.length;
        int[] dp = new int[v + 1];
        
        for (int i = 0; i < n; i++) {
            if (type[i] == 0) {
                // 01背包：倒序遍历
                for (int j = v; j >= c[i]; j--) {
                    dp[j] = Math.max(dp[j], dp[j - c[i]] + w[i]);
                }
            } else if (type[i] == 1) {
                // 完全背包：正序遍历
                for (int j = c[i]; j <= v; j++) {
                    dp[j] = Math.max(dp[j], dp[j - c[i]] + w[i]);
                }
            } else if (type[i] == 2) {
                // 多重背包：倒序遍历 + 枚举件数
                for (int j = v; j >= c[i]; j--) {
                    for (int k = 0; k <= s[i] && j >= k * c[i]; k++) {
                        dp[j] = Math.max(dp[j], dp[j - k * c[i]] + k * w[i]);
                    }
                }
            }
        }
        return dp[v];
    }
}
```

### 抽象封装版（推荐）

为了代码清晰和易于维护，可以将三种背包的处理封装成独立的方法：

```java
class Solution {
    private int[] dp;
    
    // 01背包处理
    private void zeroOnePack(int v, int c, int w) {
        for (int j = v; j >= c; j--) {
            dp[j] = Math.max(dp[j], dp[j - c] + w);
        }
    }
    
    // 完全背包处理
    private void completePack(int v, int c, int w) {
        for (int j = c; j <= v; j++) {
            dp[j] = Math.max(dp[j], dp[j - c] + w);
        }
    }
    
    // 多重背包处理
    private void multiplePack(int v, int c, int w, int s) {
        for (int j = v; j >= c; j--) {
            for (int k = 0; k <= s && j >= k * c; k++) {
                dp[j] = Math.max(dp[j], dp[j - k * c] + k * w);
            }
        }
    }
    
    // 混合背包主函数
    public int solute(int v, int[] c, int[] w, int[] type, int[] s) {
        int n = w.length;
        dp = new int[v + 1];
        
        for (int i = 0; i < n; i++) {
            if (type[i] == 0) {
                zeroOnePack(v, c[i], w[i]);
            } else if (type[i] == 1) {
                completePack(v, c[i], w[i]);
            } else if (type[i] == 2) {
                multiplePack(v, c[i], w[i], s[i]);
            }
        }
        return dp[v];
    }
}
```

---

## 完全背包与多重背包的关系

完全背包其实是多重背包的一个特例：

- 在多重背包中，每个物品有一个最大可用件数 $s[i]$，即每种物品最多只能选 $s[i]$ 次。
- 如果把 $s[i]$ 设为一个很大的数（比如 $\infty$ 或大于背包容量 $\lfloor v/c[i] \rfloor$），就变成了"每种物品可以选任意多次"，这正是完全背包的定义。
- 因此，完全背包的所有解法都可以看作是多重背包在 $s[i]$ 无限时的特例。

### 统一的三重循环实现

下面这段代码可以同时处理完全背包和多重背包（只是效率较低）：

```java
class Solution {
    /**
     * @param v 背包空间
     * @param c 物品的体积
     * @param w 物品的价值
     * @return 最大价值
     */
    public static int solute(int v, int[] c, int[] w) {
        int n = w.length;
        int[] dp = new int[v + 1];
        // 外层循环枚举每个物品
        for (int i = 0; i < n; i++) {
            // 中间循环枚举背包容量（倒序，防止同一物品被多次选）
            for (int j = v; j >= c[i]; j--) {
                // 最内层循环：枚举当前物品i选k件的所有可能（k可以为0,1,2...，只要容量允许）
                for (int k = 0; j >= k * c[i]; k++) {
                    // dp[j - k * c[i]] + k * w[i]：表示选k件物品i后，剩余容量的最优解加上k件物品i的价值
                    // 取所有k方案中的最大值
                    dp[j] = Math.max(dp[j], dp[j - k * c[i]] + k * w[i]);
                }
            }
        }
        return dp[v];
    }
}
```

**说明：**
- 这段代码是多重背包/完全背包的朴素三重循环实现。
- 最外层 i：枚举每个物品。
- 中间层 j：枚举背包容量（倒序，保证每个物品不会被重复选取）。
- 最内层 k：枚举当前物品选0~最大可选件数的所有情况。对于完全背包，k理论上可以无限大，只要不超过容量。
- 每次尝试用k件物品i填充容量j，取所有方案中的最大价值。
- 这种写法虽然效率低（时间复杂度 $O(nv^2)$），但能直观展现背包问题的本质：每个物品的所有选法都被枚举，最终取最优。

**实际应用建议：**
- 完全背包应使用更高效的两重循环正序遍历优化（$O(nv)$）。
- 多重背包由于有件数限制，通常需要三重循环或二进制优化等技巧。

---

## 举例说明

假设有5种物品，背包容量为10：
- 物品1（体积2，价值3）：01背包，只能选一次
- 物品2（体积3，价值4）：01背包，只能选一次
- 物品3（体积1，价值2）：完全背包，可选无限次
- 物品4（体积4，价值5）：多重背包，最多选2次
- 物品5（体积5，价值6）：多重背包，最多选3次

只需遍历每个物品，判断类型，分别用倒序、正序或多重背包的方式更新dp数组即可。

---

## 总结

**混合背包问题的核心思想：**
1. 所有复杂的混合背包问题，其实都是三种基本背包问题的组合。
2. 只要基础扎实，理解三种背包的本质和实现细节，遇到混合题目时就能快速拆解并解决。
3. 抽象与复用：将三种背包的处理封装成独立的方法，代码结构清晰，易于维护和扩展。
4. 这体现了动态规划中抽象和模块化思想的威力。

困难的题目都是由简单的题目组合而来，掌握基本的01背包、完全背包、多重背包思想，就可以把复杂的混合背包问题拆解成简单的子问题来解决。
