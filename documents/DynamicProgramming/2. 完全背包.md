# 背包九讲（二） —— 完全背包问题
## 题目
有 n 件物品，第 i 件物品的体积为 c[i]，价值是 w[i]，其中 i 的范围是 0 ~ n-1。
同时有一个背包，其最大的容量是 v。求背包能装下的所有的物品的价值，每件物品使用`多次`。

与 `01` 背包的区别就是每件物品可以使用多次。

## 朴素解法

### 代码实现
```java
class Solution {
    /**
     * @param v 背包空间
     * @param c 物品的体积
     * @param w 物品的价值
     * @return 最大价值
     */
    public static int solute(int v, int[] c, int[] w) {
        int n = w.length;
        int[][] dp = new int[n][v + 1];
        // 初始化第0个物品
        for (int j = 0; j <= v; j++) {
            if (j >= c[0]) {
                int maxK = j / c[0];
                dp[0][j] = maxK * w[0];
            }
        }
        // 状态转移
        for (int i = 1; i < n; i++) {
            for (int j = 0; j <= v; j++) {
                dp[i][j] = dp[i - 1][j]; // 不选当前物品
                for (int k = 1; k * c[i] <= j; k++) {
                    dp[i][j] = Math.max(dp[i][j], dp[i - 1][j - k * c[i]] + k * w[i]);
                }
            }
        }
        return dp[n - 1][v];
    }
}
```

### dp 数组的定义
```java
    首先定义一个二维的数组：dp[i][j]
    其定义为：
        在前 i 个物品的选择范围下，假设容量为 j 时的最大价值。
        也就是假设，只有 j 的容量，前 i 个物品的时候的局部最优解。
```
### 状态转移方程
$$
dp[i][j] =
\begin{cases}
dp[i-1][j],                                     & j < c[i] \\
\max (dp[i-1][j], dp[i-1][j-k*c[i]] + k*w[i]),    & j \geq k*c[i]
\end{cases}
$$
此处的状态转移方程与 `01` 背包基本一致。只是引入了数字 k。


## 一维解法 —— 针对朴素解法的优化

### 优化思路
朴素解法的时间复杂度较高（$O(n v^2)$），因为每个物品都要枚举使用次数 $k$。实际上，完全背包的状态转移只依赖于 $dp[j - c[i]]$，可以用一维数组优化，且不需要枚举 $k$，只需正序遍历容量即可。

优化后的时间复杂度为 $O(nv)$，空间复杂度为 $O(v)$。

### 代码实现
```java
class Solution {
    /**
     * @param v 背包空间
     * @param c 物品的体积
     * @param w 物品的价值
     * @return 最大价值
     */
    public static int solute(int v, int[] c, int[] w) {
        int n = w.length;
        int[] dp = new int[v + 1];
        // 外层循环枚举物品
        for (int i = 0; i < n; i++) {
            // 内层循环正序枚举容量
            for (int j = c[i]; j <= v; j++) {
                dp[j] = Math.max(dp[j], dp[j - c[i]] + w[i]);
            }
        }
        return dp[v];
    }
}
```