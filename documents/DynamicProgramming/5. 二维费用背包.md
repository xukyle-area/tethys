# 背包九讲（一） —— 二维费用背包
## 题目
有 n 件物品，第 i 件物品的体积为 c[i]，还需要额外支付的代价是 d[i]，价值是 w[i]，其中 i 的范围是 0 ~ n-1。
同时有一个背包，其最大的容量是 v。可以额外支付的总代价是 u。
求背包能装下的所有的物品的价值。

---

简单来说，就是在原来的背包问题模型上增加了一个代价。

对于第 i 个物品：
- 第一种代价为 c[i]；
- 第二种代价为 d[i]；
- 价值为 w[i]；

对于所有选择的物品，第一种代价的总和不能超过 v，第二种代价的总和不能超过 u，求可以拿到的物品的最大价值总和。
## 朴素解法

### Define `dp` Array
For dp array, $dp[i][j][k]$ means: In the range of first `i` goods, and the limit of first cost of `j` and the second cost of `k`, the value of this array means the max value we can get.
### State Transition Equation
Same as the problem before, we should find the `state transition equation` :

#### `01` 背包:
Every goods can be used one time:
$$
dp[i][j][k] =
\begin{cases}
dp[i-1][j][k],                                     & j < c[i] \ || \ k< d[i], \\
\max (dp[i-1][j][k], dp[i-1][j-c[i]][k-d[i]] + w[i]),         & else
\end{cases}
$$
#### 完全背包
Times every goods can be used is not limited:
$$
dp[i][j][k] =
\begin{cases}
dp[i-1][j][k],                                     & j < c[i] \ || \ k< d[i], \\
\max (dp[i-1][j][k], dp[i-1][j-m *c[i]][k-m*d[i]] + m*w[i]),         & (j >= m * c[i] \ && \ k >= m* d[i])
\end{cases}
$$
#### 多重背包
Times that goods `i` can be used is given by s[i]:
$$
dp[i][j][k] =
\begin{cases}
dp[i-1][j][k],                                     & j < c[i] \ || \ k< d[i], \\
\max (dp[i-1][j][k], dp[i-1][j-m *c[i]][k-m*d[i]] + m*w[i]),         & (j >= m * c[i] \ && \ k >= m* d[i] && k<=s[i])
\end{cases}
$$
### Code

```java
class Solution {
    /**
     * @param v first cost
     * @param u second cost
     * @param c first cost of each goods
     * @param d second cost of each goods
     * @param w value of each goods
     * @param s use limit of each goods
     *   1: 01 背包
     *  -1: no limit, 完全背包
     *  value: 多重背包
     * @return
     */
    public static int solute(int v, int u, int[] c, int[] d, int[] w, int[] s) {
        int n = w.length;
        int[][][] dp = new int[n][v + 1][u + 1];
        // 初始化第一个物品
        for (int j = 0; j <= v; j++) {
            for (int k = 0; k <= u; k++) {
                if (j >= c[0] && k >= d[0]) {
                    for (int m = 1; (s[0] == -1 || m <= s[0]) && m * c[0] <= j && m * d[0] <= k; m++) {
                        dp[0][j][k] = Math.max(dp[0][j][k], m * w[0]);
                    }
                }
            }
        }
        for (int i = 1; i < n; i++) {
            if (s[i] == 1) {
                // 01背包，逆向
                for (int j = v; j >= 0; j--) {
                    for (int k = u; k >= 0; k--) {
                        dp[i][j][k] = dp[i - 1][j][k];
                        if (j >= c[i] && k >= d[i]) {
                            dp[i][j][k] = Math.max(dp[i][j][k], dp[i - 1][j - c[i]][k - d[i]] + w[i]);
                        }
                    }
                }
            } else if (s[i] == -1) {
                // 完全背包，正向
                for (int j = 0; j <= v; j++) {
                    for (int k = 0; k <= u; k++) {
                        dp[i][j][k] = dp[i - 1][j][k];
                        if (j >= c[i] && k >= d[i]) {
                            dp[i][j][k] = Math.max(dp[i][j][k], dp[i][j - c[i]][k - d[i]] + w[i]);
                        }
                    }
                }
            } else {
                // 多重背包，逆向
                for (int j = v; j >= 0; j--) {
                    for (int k = u; k >= 0; k--) {
                        dp[i][j][k] = dp[i - 1][j][k];
                        for (int m = 1; m <= s[i] && j >= m * c[i] && k >= m * d[i]; m++) {
                            dp[i][j][k] = Math.max(dp[i][j][k], dp[i - 1][j - m * c[i]][k - m * d[i]] + m * w[i]);
                        }
                    }
                }
            }
        }
        return dp[n - 1][v][u];
    }
}
```
## 简化解法
### 状态转移方程
同样的，这个也可以去掉物品数量维度的 dp，将dp简化成二维，也就是：$ dp[j][k] $

#### 01 背包
**倒序遍历**：`for j = v → c[i]`，`for k = u → d[i]`

$$
dp[j][k] = \max(dp[j][k], dp[j-c[i]][k-d[i]] + w[i]), \quad j \geq c[i] \text{ and } k \geq d[i]
$$

#### 完全背包
**正序遍历**：`for j = c[i] → v`，`for k = d[i] → u`

$$
dp[j][k] = \max(dp[j][k], dp[j-c[i]][k-d[i]] + w[i]), \quad j \geq c[i] \text{ and } k \geq d[i]
$$

**说明**：完全背包优化后不需要枚举 m，正序遍历时 `dp[j-c[i]][k-d[i]]` 可能已经包含物品 i，从而实现重复选取。所以公式与01背包一样。

#### 多重背包（朴素版）
**倒序遍历**：`for j = v → c[i]`，`for k = u → d[i]`

$$
dp[j][k] = \max_{m=0}^{s[i]} \{dp[j-m \cdot c[i]][k-m \cdot d[i]] + m \cdot w[i]\}, \quad j \geq m \cdot c[i] \text{ and } k \geq m \cdot d[i]
$$

**说明**：需要枚举选取的件数 m（从 0 到 s[i]），每选 m 件物品获得价值 $m \cdot w[i]$。

### Code
```java
class Solution {
    /**
     * @param v first cost
     * @param u second cost
     * @param c first cost of each goods
     * @param d second cost of each goods
     * @param w value of each goods
     * @param s use limit of each goods
     *   1: 01 背包
     *  -1: no limit, 完全背包
     *  value: 多重背包
     * @return
     */
    public static int solute(int v, int u, int[] c, int[] d, int[] w, int[] s) {
        int n = w.length;
        int[][] dp = new int[v + 1][u + 1];

        for (int i = 0; i < n; i++) {
            if (s[i] == 1) {
                // 01背包，逆向
                for (int j = v; j >= 0; j--) {
                    for (int k = u; k >= 0; k--) {
                        if (j >= c[i] && k >= d[i]) {
                            dp[j][k] = Math.max(dp[j][k], dp[j - c[i]][k - d[i]] + w[i]);
                        }
                    }
                }
            } else if (s[i] == -1) {
                // 完全背包，正向
                for (int j = 0; j <= v; j++) {
                    for (int k = 0; k <= u; k++) {
                        if (j >= c[i] && k >= d[i]) {
                            dp[j][k] = Math.max(dp[j][k], dp[j - c[i]][k - d[i]] + w[i]);
                        }
                    }
                }
            } else {
                // 多重背包，逆向
                for (int j = v; j >= 0; j--) {
                    for (int k = u; k >= 0; k--) {
                        for (int m = 1; m <= s[i] && j >= m * c[i] && k >= m * d[i]; m++) {
                            dp[j][k] = Math.max(dp[j][k], dp[j - m * c[i]][k - m * d[i]] + m * w[i]);
                        }
                    }
                }
            }
        }
        return dp[v][u];
    }
}
```