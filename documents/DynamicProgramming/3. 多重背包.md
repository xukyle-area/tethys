# 背包九讲（三） —— 多重背包
## 题目
有 n 件物品，第 i 件物品的体积为 c[i]，价值是 w[i]，其中 i 的范围是 0 ~ n-1。
同时有一个背包，其最大的容量是 v。求背包能装下的所有的物品的价值，每件物品可以使用的次数为 s[i] 。

与前面的背包的区别就是，在这个问题里面每件物品可以使用次数不是一次，也不是无限次，而是给出了指定的限制。

## 朴素解法
### dp 数组的定义
```java
    首先定义一个二维的数组：dp[i][j]
    其定义为：
        在前 i 个物品的选择范围下，假设容量为 j 时的最大价值。
        也就是假设，只有 j 的容量，前 i 个物品的时候的局部最优解。
```
### 状态转移方程
$$
dp[i][j] =
\begin{cases}
dp[i-1][j],                                     & j < c[i] \\
\max (dp[i-1][j], dp[i-1][j-k*c[i]] + k*w[i]),    & 0<k<s[i],0<k*c[i] ≤j
\end{cases}
$$
此处的状态转移方程与 `01` 背包也是基本一致。
只是引入了一个数字k，表示第 i 个物品使用的次数。k 的范围是 0 ~ s[i] 。同时 k 还需要满足 k*c[i] ≤ j ，也就是使用 k 次物品 i 所占用的空间不能超过当前背包的容量 j 。

### 代码实现
```java
class Solution {
    /**
     * @param v 背包空间
     * @param c 物品的体积
     * @param w 物品的价值
     * @return 最大价值
     */
    public static int solute(int v, int[] c, int[] w, int[] s) {
        int n = w.length;
        int[][] dp = new int[n][v + 1];
        // 初始化第0个物品，让 dp[0][0:v] 有值
        for (int j = c[0]; j <= v; j++) {
            // 也就是尝试当空间为 [0, v] 的时候，能不能装下第一件物品
            dp[0][j] = w[0];
        }
        // 前面初始化过了 dp[0][0:v] ，所以这里从 1 开始
        for (int i = 1; i < n; i++) {
            // 固定物品数量，逐一尝试各种背包容量
            for (int j = 0; j <= v; j++) {
                //=========================下面有不同=========================
                int cur = 0;
                for (int k = 1; k <= s[i]; k++) {
                    if (j < k * c[i]) {
                        break;
                    }
                    cur = Math.max(dp[i - 1][j], dp[i - 1][j - k * c[i]] + k * w[i]);
                }
                dp[i][j] = cur;
                //=========================上面有不同=========================
            }
        }
        return dp[n - 1][v];
    }
}
```

## 一维解法
与 `01` 背包类似，也可以将二维 dp 数组变成一维 dp 数组，因为在计算的过程中也总是只是用上一轮遍历的结果。
### 一维解法代码
```java
class Solution {
    /**
     * @param v 背包空间
     * @param c 物品的体积
     * @param w 物品的价值
     * @param s 物品的件数
     * @return 最大价值
     */
    public static int solute(int v, int[] c, int[] w, int[] s) {
        int n = w.length;
        int[] dp = new int[v + 1];
        for (int i = 0; i < n; i++) {
            for (int j = v; j >= c[i]; j--) {
                // 最内层的k循环，枚举第i个物品选0~s[i]件的所有可能
                for (int k = 0; k <= s[i] && j >= k * c[i]; k++) {
                    // k <= s[i]：不能超过物品i的最大件数
                    // j >= k * c[i]：背包剩余容量要能放下k件物品i
                    // dp[j - k * c[i]] + k * w[i]：表示选k件物品i后，剩余容量的最优解加上k件物品i的价值
                    dp[j] = Math.max(dp[j], dp[j - k * c[i]] + k * w[i]);
                }
            }
        }
        return dp[v];
    }
}
```