# 背包九讲（一） —— `01` 背包问题
## 题目
有 n 件物品，第 i 件物品的体积为 c[i]，价值是 w[i]，其中 i 的范围是 0 ~ n-1。
同时有一个背包，其最大的容量是 v。求背包能装下的所有的物品的价值，每件物品使用一次。

这是一个经典的动态规划问题，也是动态规划的入门篇章。对于动态规划问题，最重要的是动态规划数组的定义以及状态转移方程。

## 解法 1

### dp 数组的定义
```java
    首先定义一个二维的数组：dp[i][j]
    其定义为：
        在前 i 个物品的选择范围下，假设容量为 j 时的最大价值。
        也就是假设，只有 j 的容量，前 i 个物品的时候的局部最优解。
```
### 状态转移方程
对于第 i 个物品可以有下面分支讨论：

- 假设背包清空，只装第 i 个物品，能不能装得下？
  - 情况a：装不下，那肯定就不装，相当于没有物品 i 。
  - 装得下，就又需要讨论挪出装第 i 个物品的空间值不值得。
    - 情况b：装入，假设空间减少 c[i]，但是价值增加 w[i]。
    - 情况c：不装入，相当于没有物品 i 。

$$
dp[i][j] =
\begin{cases}
dp[i-1][j],                                     & j < c[i] \\
\max \{dp[i-1][j], dp[i-1][j-c[i]] + w[i] \},    & j \geq c[i]
\end{cases}
$$
```java
class Solution {
    /**
     * @param v 背包空间
     * @param c 物品的体积
     * @param w 物品的价值
     * @return 最大价值
     */
    public static int solute(int v, int[] c, int[] w) {
        int n = w.length;
        int[][] dp = new int[n][v + 1];
        // 初始化第0个物品，让 dp[0][0:v] 有值
        for (int j = c[0]; j <= v; j++) {
            // 也就是尝试当空间为 [0, v] 的时候，能不能装下第一件物品
            dp[0][j] = w[0];
        }
        // 前面初始化过了 dp[0][0:v] ，所以这里从 1 开始
        for (int i = 1; i < n; i++) {
            // 固定物品数量，逐一尝试各种背包容量
            for (int j = 0; j <= v; j++) {
                if (j < c[i]) {
                    dp[i][j] = dp[i - 1][j];
                } else {
                    dp[i][j] = Math.max(dp[i - 1][j], dp[i - 1][j - c[i]] + w[i]);
                }
            }
        }
        return dp[n - 1][v];
    }
}
```

## 解法 2 —— 针对解法 1 的优化

原二维写法：
- $dp[i][j]$ 表示前 $i$ 个物品，容量为 $j$ 时的最大价值。
- 每次用 $dp[i-1][j]$ 和 $dp[i-1][j-c[i]] + w[i]$ 更新。

但其实每一层 $i$ 只依赖上一层 $i-1$，所以我们可以只用一维数组 $dp[j]$，每次用旧值更新新值。

### dp 数组的定义
```
定义一个数组：dp[i]
    其定义为：
        在容量为 i 时，可以装下的物品的最大值。
```
### 状态转移方程
$$
dp[i] = \max \{dp[i], dp[j-c[i]] + w[i] \}
$$

### 代码

```java
class Solution {
    /**
     * @param v 背包空间
     * @param c 物品的体积
     * @param w 物品的价值
     * @return 最大价值
     */
    public static int solute(int v, int[] c, int[] w) {
        int n = w.length;
        int[] dp = new int[v + 1];
        // 外层按照物品枚举
        for (int i = 0; i < n; i++) {
            // 内层按照容量进行枚举
            // 必须倒序遍历容量 j，否则数据会被覆盖掉，导致后面的数据用到不是上一轮的数据，而是当前轮的数据
            for (int j = v; j >= c[i]; j--) {
                // max 方法中使用到的 dp 数组就是上一轮的结果
                dp[j] = Math.max(dp[j], dp[j - c[i]] + w[i]);
            }
        }
        return dp[v];
    }

    public static void main(String[] args) {
        int v = 10;
        int[] c = {2, 3, 5, 7};
        int[] w = {1, 3, 5, 9};
        int result = Solution.solute(v, c, w);
        System.out.println(result);
    }
}
```
### 倒序的原因

如果不倒序遍历容量 j，$dp[j - c[i]]$ 可能已经被本轮的物品更新过，导致同一个物品被多次使用（变成完全背包的转移方式）。倒序遍历可以保证每个物品只用一次，$dp[j - c[i]]$ 用到的还是上一轮（上一件物品）留下来的值。