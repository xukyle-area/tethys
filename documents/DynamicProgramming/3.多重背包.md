# 背包九讲（三） —— 多重背包
## 题目
有 n 件物品，第 i 件物品的体积为 c[i]，价值是 w[i]，其中 i 的范围是 0 ~ n-1。
同时有一个背包，其最大的容量是 v。求背包能装下的所有的物品的价值，每件物品可以使用的次数为 s[i] 。

与前面的背包的区别就是，在这个问题里面每件物品可以使用次数不是一次，也不是无限次，而是给出了指定的限制。

## 朴素解法
### dp 数组的定义
```java
    首先定义一个二维的数组：dp[i][j]
    其定义为：
        在前 i 个物品的选择范围下，假设容量为 j 时的最大价值。
        也就是假设，只有 j 的容量，前 i 个物品的时候的局部最优解。
```
### 状态转移方程
$$
dp[i][j] =
\begin{cases}
dp[i-1][j],                                     & j < c[i] \\
\max (dp[i-1][j], dp[i-1][j-k*c[i]] + k*w[i]),    & 0<k<s[i],0<k*c[i] ≤j
\end{cases}
$$
此处的状态转移方程与 `01` 背包也是基本一致。
只是引入了一个数字k，表示第 i 个物品使用的次数。k 的范围是 0 ~ s[i] 。同时 k 还需要满足 k*c[i] ≤ j ，也就是使用 k 次物品 i 所占用的空间不能超过当前背包的容量 j 。

### 代码实现
```java
class Solution {
    /**
     * @param v 背包空间
     * @param c 物品的体积
     * @param w 物品的价值
     * @return 最大价值
     */
    public static int solute(int v, int[] c, int[] w, int[] s) {
        int n = w.length;
        int[][] dp = new int[n][v + 1];
        // 初始化第0个物品，让 dp[0][0:v] 有值
        for (int j = c[0]; j <= v; j++) {
            // 也就是尝试当空间为 [0, v] 的时候，能不能装下第一件物品
            dp[0][j] = w[0];
        }
        // 前面初始化过了 dp[0][0:v] ，所以这里从 1 开始
        for (int i = 1; i < n; i++) {
            // 固定物品数量，逐一尝试各种背包容量
            for (int j = 0; j <= v; j++) {
                //=========================下面有不同=========================
                int cur = 0;
                for (int k = 1; k <= s[i]; k++) {
                    if (j < k * c[i]) {
                        break;
                    }
                    cur = Math.max(dp[i - 1][j], dp[i - 1][j - k * c[i]] + k * w[i]);
                }
                dp[i][j] = cur;
                //=========================上面有不同=========================
            }
        }
        return dp[n - 1][v];
    }
}
```

## 一维解法
与 `01` 背包类似，也可以将二维 dp 数组变成一维 dp 数组，因为在计算的过程中也总是只是用上一轮遍历的结果。
### 一维解法代码
```java
class Solution {
    /**
     * @param v 背包空间
     * @param c 物品的体积
     * @param w 物品的价值
     * @param s 物品的件数
     * @return 最大价值
     */
    public static int solute(int v, int[] c, int[] w, int[] s) {
        int n = w.length;
        int[] dp = new int[v + 1];
        for (int i = 0; i < n; i++) {
            for (int j = v; j >= c[i]; j--) {
                // 最内层的k循环，枚举第i个物品选0~s[i]件的所有可能
                for (int k = 0; k <= s[i] && j >= k * c[i]; k++) {
                    // k <= s[i]：不能超过物品i的最大件数
                    // j >= k * c[i]：背包剩余容量要能放下k件物品i
                    // dp[j - k * c[i]] + k * w[i]：表示选k件物品i后，剩余容量的最优解加上k件物品i的价值
                    dp[j] = Math.max(dp[j], dp[j - k * c[i]] + k * w[i]);
                }
            }
        }
        return dp[v];
    }
}
```

#### 说明：
- 这段代码的核心在于最内层的 `for (int k = 0; k <= s[i] && j >= k * c[i]; k++)`。
- 这个循环枚举了第i个物品可以选0件、1件、2件……最多s[i]件的所有情况。
- `k <= s[i]` 保证不会超过物品i的最大可用数量。
- `j >= k * c[i]` 保证背包容量足够放下k件物品i。
- 每次都尝试用k件物品i填充容量j，取所有方案中的最大价值。
- 这种写法是多重背包的朴素做法，时间复杂度较高（O(n*v*max(s[i]))），但思路直观。

## 反向：从多重背包到完全背包

```java
class Solution {
    /**
     * @param v 背包空间
     * @param c 物品的体积
     * @param w 物品的价值
     * @return 最大价值
     */
    public static int solute(int v, int[] c, int[] w) {
        int n = w.length;
        int[] dp = new int[v + 1];
        // 外层循环枚举每个物品
        for (int i = 0; i < n; i++) {
            // 中间循环枚举背包容量（倒序，防止同一物品被多次选）
            for (int j = v; j >= c[i]; j--) {
                // 最内层循环：枚举当前物品i选k件的所有可能（k可以为0,1,2...，只要容量允许）
                for (int k = 0; j >= k * c[i]; k++) {
                    // dp[j - k * c[i]] + k * w[i]：表示选k件物品i后，剩余容量的最优解加上k件物品i的价值
                    // 取所有k方案中的最大值
                    dp[j] = Math.max(dp[j], dp[j - k * c[i]] + k * w[i]);
                }
            }
        }
        return dp[v];
    }
}
```

### 代码解释
- 这段代码是多重背包/完全背包的朴素三重循环实现。
- 最外层 i：枚举每个物品。
- 中间层 j：枚举背包容量（倒序，保证每个物品不会被重复选取）。
- 最内层 k：枚举当前物品选0~最大可选件数的所有情况。对于完全背包，k理论上可以无限大，只要不超过容量。
- 每次尝试用k件物品i填充容量j，取所有方案中的最大价值。
- 这种写法虽然效率低，但能直观展现背包问题的本质：每个物品的所有选法都被枚举，最终取最优。

### 与多重背包的关系

完全背包其实是多重背包的一个特例。

- 在多重背包中，每个物品有一个最大可用件数 $s[i]$，即每种物品最多只能选 $s[i]$ 次。
- 如果把 $s[i]$ 设为一个很大的数（比如 $\infty$ 或大于背包容量 $v/c[i]$），就变成了“每种物品可以选任意多次”，这正是完全背包的定义。
- 因此，完全背包的所有解法（包括三重循环、正序一维优化等）都可以看作是多重背包在 $s[i]$ 无限时的特例。
- 反过来，多重背包的解法也可以直接用于完全背包，只是效率会低一些。

在实际实现时，完全背包可以用更高效的两重循环正序遍历来优化，而多重背包由于有件数限制，通常需要三重循环或二进制优化等技巧。

## 三类背包问题的顺序与优化对比

| 问题类型 | 内层容量遍历顺序    | 内部条件/循环                   | 一维优化代码核心                                                                                                                |
| -------- | ------------------- | ------------------------------- | ------------------------------------------------------------------------------------------------------------------------------- |
| 01背包   | 倒序 (j = v → c[i]) | 只允许每个物品用一次            | for (int j = v; j >= c[i]; j--)<br>dp[j] = max(dp[j], dp[j-c[i]] + w[i]);                                                       |
| 完全背包 | 正序 (j = c[i] → v) | 每个物品可用无限次              | for (int j = c[i]; j <= v; j++)<br>dp[j] = max(dp[j], dp[j-c[i]] + w[i]);                                                       |
| 多重背包 | 倒序 (j = v → c[i]) | 每个物品最多用 s[i] 次，需枚举k | for (int j = v; j >= c[i]; j--)<br>for (int k = 0; k <= s[i] && j >= k*c[i]; k++)<br>dp[j] = max(dp[j], dp[j-k*c[i]] + k*w[i]); |

### 说明：
- 01背包倒序遍历容量，防止同一物品被多次选取。
- 完全背包正序遍历容量，允许同一物品被多次选取。
- 多重背包倒序遍历容量，并在内部枚举每种可选件数k，保证不超过最大件数限制。
- 多重背包可以用二进制优化或单调队列优化进一步提升效率，但朴素做法如上。