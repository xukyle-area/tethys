# 背包九讲（六） —— 分组背包
## 题目

对于第 i 个物品：
- 代价为 c[i]；
- 价值为 w[i]；

对于所有选择的物品，代价的总和不能超过 v，求可以拿到的物品的最大价值总和。

---

上面部分的条件和 01 背包一致。不过在此处增加了一个条件：每个物品存在一个组 id，每个组的物品只能取`一件`。

## 朴素解法

### dp 数组的定义
$dp[g][j]$：
- g 表示前 g 组物品；
- j 表示可以使用的总代价；

所以，$dp[g][j]$ 表示前 g 组物品，在使用最大为 j 空间的情况下，可以拿到的最大价值。

### 状态转移方程
$$
dp[g][j] = max(dp[g-1][j],\ dp[g-1][j-c[i]]+w[i]),  j \geq c[i] \text{ and } goods\ i\ belongs\ to\ group\ g
$$

### Code
```java
class Solution {
    /**
     * @param v 总共花费
     * @param costs 每个的花费
     * @param values 每个的价值
     * @param groups 每个的分组，组 id 从 1 开始自增一直到 gCount
     * @return
     */
    public static int solute(int v, int[] costs, int[] values, int[] groups) {
        // count of groups
        int gCount = 0;
        for (int i : groups) {
            gCount = Math.max(gCount, i);
        }
        int[][] dp = new int[gCount + 1][v + 1];
        int n = values.length;

        for (int g = 1; g <= gCount; g++) {
            for (int j = 0; j <= v; j++) dp[g][j] = dp[g - 1][j];

            // 下面的两层 for 其实本质上就是一层 for，即，对物品的 costs 进行遍历
            for (int i = 0; i < n; i++) {
                if (g != groups[i]) continue;

                // 倒序遍历容量
                for (int j = v; j >= costs[i]; j--) {
                    // dp[g][j] 可能已经包含了同组其他物品的结果
                    dp[g][j] = Math.max(dp[g][j], dp[g - 1][j - costs[i]] + values[i]);
                }
            }
        }
        return dp[gCount][v];
    }
}
```