# 1. [Two Sum](https://leetcode.com/problems/two-sum/)

### 题目描述
给定一个整数数组 `nums` 和一个目标值 `target`，找出数组中和为目标值的两个数的索引。假设每个输入只对应一个答案，且同一个元素不能使用两次。

例如：`nums = [2,7,11,15]`, `target = 9`
输出：`[0,1]`（因为 `nums[0] + nums[1] = 2 + 7 = 9`）

### 核心思想
使用**哈希表**优化查找过程，将时间复杂度从 $O(n^2)$ 降到 $O(n)$。遍历数组时，检查 `target - nums[i]` 是否已在哈希表中，若在则找到答案；否则将当前元素加入哈希表。

### 关键点
1. **哈希表存储**：Key 是数组元素值，Value 是该元素的索引
2. **一次遍历**：边遍历边查找，无需预先填充哈希表
3. **避免重复**：先查找再插入，确保不会使用同一个元素两次

### 复杂度分析
- **时间复杂度**：$O(n)$，单次遍历数组
- **空间复杂度**：$O(n)$，哈希表存储空间

**注**：下面代码为暴力解法 $O(n^2)$，更优解法应使用哈希表。

```java
package com.ganten.tethys;

public class Solution {

    public int[] twoSum(int[] nums, int target) {
        // 暴力解法：双重循环枚举所有配对
        for (int i = 0; i < nums.length; i++) {
            for (int j = i + 1; j < nums.length; j++) {
                if (nums[i] + nums[j] == target) {
                    return new int[] {i, j};
                }
            }
        }
        return new int[] {0, 0};
    }

    public static void main(String[] args) {
        Solution solution = new Solution();
        int[] nums = {2, 7, 11, 15};
        int target = 9;
        int[] result = solution.twoSum(nums, target);
        System.out.println("Indices: " + result[0] + ", " + result[1]);
    }
}
```
# 217. [Contains Duplicate](https://leetcode.com/problems/contains-duplicate)

### 题目描述
给定一个整数数组 `nums`，如果任意一个值在数组中出现至少两次，返回 `true`；如果数组中每个元素都不相同，返回 `false`。

例如：`nums = [1,2,3,1]` → 输出 `true`

### 核心思想
使用**哈希集合（HashSet）**记录已遍历过的元素。遍历数组时，若当前元素已在集合中，说明存在重复，返回 `true`；否则将元素加入集合。

### 关键点
1. **HashSet.add() 返回值**：返回 `false` 表示元素已存在（添加失败），即发现重复
2. **提前返回**：一旦发现重复立即返回，无需继续遍历
3. **集合特性**：自动去重，快速查找（$O(1)$ 平均时间）

### 复杂度分析
- **时间复杂度**：$O(n)$，遍历数组一次
- **空间复杂度**：$O(n)$，最坏情况下集合存储所有元素

```java
package com.ganten.tethys;

import java.util.HashSet;

public class Solution {
    public boolean containsDuplicate(int[] nums) {
        HashSet<Integer> hashSet = new HashSet<Integer>();
        for (int num : nums) {
            // add() 返回 false 表示元素已存在，即发现重复
            if (!hashSet.add(num)) {
                return true;
            }
        }
        return false;  // 没有重复元素
    }

    public static void main(String[] args) {
        Solution solution = new Solution();
        int[] nums = {1, 2, 3, 1};
        System.out.println(solution.containsDuplicate(nums));
    }
}
```
# 219. [Contains Duplicate II](https://leetcode.com/problems/contains-duplicate-ii/description/)

### 题目描述
给定一个整数数组 `nums` 和一个整数 `k`，判断数组中是否存在两个不同的索引 `i` 和 `j`，使得 `nums[i] == nums[j]` 且 `|i - j| <= k`。

例如：`nums = [1,2,3,1,2,3]`, `k = 2` → 输出 `false`

### 核心思想
使用**哈希表**记录每个元素最近一次出现的索引。遍历数组时，若当前元素之前出现过，检查索引差是否 ≤ k；无论是否满足条件，都更新该元素的索引为当前位置（保持最近的索引）。

### 关键点
1. **哈希表存储**：Key 是元素值，Value 是该元素最近一次出现的索引
2. **索引差判断**：`index - map.get(num) <= k`
3. **索引更新**：每次都更新为当前索引，确保记录的是最近位置

### 复杂度分析
- **时间复杂度**：$O(n)$，遍历数组一次
- **空间复杂度**：$O(\min(n, k))$，哈希表最多存储 k 个元素

```java
package com.ganten.tethys;

import java.util.HashMap;
import java.util.Map;

public class Solution {
    public boolean containsNearbyDuplicate(int[] nums, int k) {
        Map<Integer, Integer> map = new HashMap<>();  // 值 -> 最近索引
        for (int index = 0; index < nums.length; index++) {
            int num = nums[index];
            if (map.containsKey(num)) {
                // 检查索引差是否满足条件
                if (index - map.get(num) <= k) {
                    return true;
                }
            }
            // 更新为最近索引
            map.put(num, index);
        }
        return false;
    }

    public static void main(String[] args) {
        Solution solution = new Solution();
        int[] nums = {1, 2, 3, 1, 2, 3};
        System.out.println(solution.containsNearbyDuplicate(nums, 2));
    }
}
```

# 220. [Contains Duplicate III](https://leetcode.com/problems/contains-duplicate-iii/description/)
```java
package com.ganten.tethys;

import java.util.HashMap;
import java.util.Map;

public class Solution {
    public boolean containsNearbyAlmostDuplicate(int[] nums, int indexDiff, int valueDiff) {
        int min = Integer.MAX_VALUE, n = nums.length;
        for (int num : nums) {
            min = Math.min(min, num);
        }
        // index -> value
        Map<Integer, Integer> buckets = new HashMap<>();
        int bucketSize = valueDiff + 1;
        for (int i = 0; i < n; i++) {
            if (i > indexDiff) {
                int rm = nums[i - indexDiff - 1];
                int bktId = (rm - min) / bucketSize;
                buckets.remove(bktId);
            }
            int cur = nums[i];
            int bktId = (cur - min) / bucketSize;
            if (buckets.containsKey(bktId)) {
                return true;
            }
            buckets.put(bktId, cur);
            if (buckets.containsKey(bktId - 1) && Math.abs(buckets.get(bktId - 1) - cur) <= valueDiff) {
                return true;
            }
            if (buckets.containsKey(bktId + 1) && Math.abs(buckets.get(bktId + 1) - cur) <= valueDiff) {
                return true;
            }
        }
        return false;
    }

    public static void main(String[] args) {
        Solution solution = new Solution();
        int[] nums = {1, 2, 3, 1};
        System.out.println(solution.containsNearbyAlmostDuplicate(nums, 3, 0));
    }
}
```

这段代码的核心功能是**判断数组中是否存在两个元素，它们的索引差不超过 `indexDiff`，且数值差不超过 `valueDiff`**（即题目「存在重复元素 III」的解法）。下面从「功能、核心思路、代码细节、示例验证」四个维度详细解释：


### 一、核心功能（对应题目要求）
给定一个整数数组 `nums`、两个整数 `indexDiff` 和 `valueDiff`，返回 `true` 或 `false`：
- 存在一对元素 `nums[i]` 和 `nums[j]`（`i ≠ j`）
- 满足两个条件：
  1. 索引差约束：`|i - j| ≤ indexDiff`（两个元素的位置不能太远）
  2. 数值差约束：`|nums[i] - nums[j]| ≤ valueDiff`（两个元素的大小不能差太多）


### 二、核心解题思路：桶排序（空间换时间）
直接暴力枚举所有元素对（`O(n²)` 时间）会超时，因此代码采用「桶排序」优化，将时间复杂度降到 `O(n)`，核心思路如下：
1. **桶的定义**：把数值范围划分成多个「桶」，每个桶的大小为 `valueDiff + 1`（关键设计）。
   - 例如：`valueDiff = 3` 时，桶大小为 4，每个桶包含的数值范围是 `[0,3]、[4,7]、[8,11]` 等。
   - 原理：**同一个桶内的任意两个数，数值差一定 ≤ valueDiff**（因为桶大小是 `valueDiff+1`，最大差值就是桶大小-1 = valueDiff）。
2. **索引约束处理**：用一个哈希表 `buckets` 存储「当前窗口内的元素对应的桶」，窗口大小为 `indexDiff`（即只保留最近 `indexDiff` 个元素的桶）。
   - 当遍历到第 `i` 个元素时，先移除窗口外的元素（`i > indexDiff` 时，移除 `i - indexDiff - 1` 位置的元素对应的桶），保证窗口内元素的索引差都 ≤ indexDiff。
3. **数值约束判断**：
   - 若当前元素的桶已存在于哈希表中：说明窗口内有同桶元素，数值差满足条件，直接返回 `true`。
   - 若当前元素的「前一个桶」或「后一个桶」存在于哈希表中：需要计算当前元素与相邻桶元素的数值差，若 ≤ valueDiff，返回 `true`（相邻桶可能存在满足条件的元素）。
   - 若以上都不满足：将当前元素的桶加入哈希表，继续遍历。


### 三、代码细节拆解
#### 1. 计算数组最小值 `min`
```java
int min = Integer.MAX_VALUE, n = nums.length;
for (int num : nums) {
    min = Math.min(min, num);
}
```
- 目的：将所有数值「平移」到非负区间（避免负数计算桶ID时出现异常）。
- 例如：数组中有负数 `-2`，`min = -5`，则 `-2 - (-5) = 3`（平移后为正数，桶ID计算更直观）。

#### 2. 桶大小定义
```java
int bucketSize = valueDiff + 1;
```
- 关键设计：确保同一个桶内的元素数值差 ≤ valueDiff（比如 `valueDiff=0` 时，桶大小=1，同一个桶内元素完全相等）。

#### 3. 遍历数组，维护滑动窗口和桶
```java
for (int i = 0; i < n; i++) {
    // 步骤1：移除窗口外的元素（保证索引差 ≤ indexDiff）
    if (i > indexDiff) {
        int rm = nums[i - indexDiff - 1]; // 窗口最左侧元素
        int bktId = (rm - min) / bucketSize; // 该元素的桶ID
        buckets.remove(bktId); // 从哈希表中删除这个桶
    }

    // 步骤2：计算当前元素的桶ID
    int cur = nums[i];
    int bktId = (cur - min) / bucketSize;

    // 步骤3：判断是否满足条件
    if (buckets.containsKey(bktId)) {
        // 同桶元素存在，数值差一定满足
        return true;
    }
    // 检查前一个桶（bktId-1）
    if (buckets.containsKey(bktId - 1) && Math.abs(buckets.get(bktId - 1) - cur) <= valueDiff) {
        return true;
    }
    // 检查后一个桶（bktId+1）
    if (buckets.containsKey(bktId + 1) && Math.abs(buckets.get(bktId + 1) - cur) <= valueDiff) {
        return true;
    }

    // 步骤4：将当前元素的桶加入哈希表（桶中存储当前元素值，用于相邻桶判断）
    buckets.put(bktId, cur);
}
```

#### 4. 哈希表 `buckets` 的作用
- Key：桶ID（整数），表示当前窗口内存在该桶。
- Value：该桶对应的元素值（同一个桶内最多只有一个元素，因为一旦有两个就会直接返回 `true`）。


### 四、示例验证（main方法中的测试用例）
测试用例：`nums = [1,2,3,1]`，`indexDiff=3`，`valueDiff=0`
- 需求：找两个「索引差≤3」且「数值相等」（valueDiff=0）的元素。

#### 遍历过程：
1. `i=0`（cur=1）：
   - 窗口未超出（i≤3），无需移除元素。
   - 桶ID = (1 - 1) / 1 = 0（min=1，bucketSize=0+1=1）。
   - 哈希表无桶0，也无桶-1/1，加入桶0→1。哈希表：{0:1}。

2. `i=1`（cur=2）：
   - 窗口未超出，无需移除。
   - 桶ID = (2-1)/1=1。
   - 哈希表无桶1，检查桶0（1）：|1-2|=1>0，不满足；无桶2。加入桶1→2。哈希表：{0:1, 1:2}。

3. `i=2`（cur=3）：
   - 窗口未超出，无需移除。
   - 桶ID=(3-1)/1=2。
   - 哈希表无桶2，检查桶1（2）：|2-3|=1>0；无桶3。加入桶2→3。哈希表：{0:1, 1:2, 2:3}。

4. `i=3`（cur=1）：
   - 窗口未超出（i=3 ≤ indexDiff=3），无需移除。
   - 桶ID=(1-1)/1=0。
   - 哈希表已包含桶0（对应值1），直接返回 `true`。

最终输出 `true`，符合预期（元素1和索引3的元素1，索引差3≤3，数值差0≤0）。


### 总结
- 功能：解决「存在重复元素 III」问题，判断数组中是否有索引差≤indexDiff且数值差≤valueDiff的元素对。
- 核心：用「桶排序」将数值分组，通过哈希表维护滑动窗口内的桶，快速判断是否存在满足条件的元素对（时间复杂度O(n)）。
- 关键设计：桶大小=valueDiff+1（保证同桶元素满足数值差条件）、数值平移（处理负数）、滑动窗口（处理索引差条件）。

# 36. [Valid Sudoku](https://leetcode.com/problems/valid-sudoku/description/)

### 题目描述
判断一个 9x9 的数独是否有效。只需要根据以下规则验证已经填入的数字是否有效：
1. 每一行的数字 1-9 不能重复
2. 每一列的数字 1-9 不能重复
3. 每个 3x3 子宫格内的数字 1-9 不能重复

注意：空白格用 `'.'` 表示，数独部分填空，不需要判断是否可解。

### 核心思想
使用**三个二维数组分别记录行、列、子宫格中每个数字的出现次数**。遍历棋盘一次，同时更新三个记录数组，若任何数字出现次数超过 1，则无效。

### 关键点
1. **行记录**：`rows[i][index]` 表示第 i 行中数字 (index+1) 的出现次数
2. **列记录**：`cols[j][index]` 表示第 j 列中数字 (index+1) 的出现次数
3. **子宫格记录**：`subboxes[i/3][j/3][index]` 表示对应子宫格中数字 (index+1) 的出现次数
4. **索引计算**：`index = c - '0' - 1`（字符 '1'-'9' 映射到 0-8）
5. **子宫格定位**：`i/3` 和 `j/3` 确定属于哪个 3x3 子宫格

### 复杂度分析
- **时间复杂度**：$O(1)$，固定遍历 81 个格子
- **空间复杂度**：$O(1)$，固定大小的记录数组

```java
package com.ganten.tethys;

public class Solution {
    public boolean isValidSudoku(char[][] board) {
        int[][] cols = new int[9][9];      // 列记录
        int[][] rows = new int[9][9];      // 行记录
        int[][][] subboxes = new int[3][3][9];  // 子宫格记录
        
        for (int i = 0; i < board.length; i++) {
            for (int j = 0; j < board[0].length; j++) {
                char c = board[i][j];
                if (c != '.') {
                    int index = c - '0' - 1;  // 字符 '1'-'9' 映射到索引 0-8
                    rows[i][index]++;         // 第 i 行的数字计数
                    cols[j][index]++;         // 第 j 列的数字计数
                    subboxes[i / 3][j / 3][index]++;  // 对应子宫格的数字计数
                    
                    // 任何位置出现次数 > 1 则无效
                    if (rows[i][index] > 1 || cols[j][index] > 1 || subboxes[i / 3][j / 3][index] > 1) {
                        return false;
                    }
                }
            }
        }
        return true;
    }
}

```

# 73. [Set Matrix Zeroes](https://leetcode.com/problems/set-matrix-zeroes/description/)

### 题目描述
给定一个 m x n 的矩阵，如果一个元素为 0，则将其所在行和列的所有元素都设置为 0。要求原地修改矩阵。

### 核心思想
使用**标记值**来区分原始的 0 和需要被置为 0 的元素。分两步执行：
1. 遍历矩阵，找到所有原始的 0，将其所在行和列的非 0 元素标记为特殊值（MM）
2. 再次遍历矩阵，将所有标记值转换为 0

### 关键点
1. **标记值选择**：使用一个不可能出现在输入中的值（如 -7349234）作为标记
2. **两步处理**：
   - 第一步：标记需要置零的位置（使用 MM）
   - 第二步：将标记值转换为真正的 0
3. **原地操作**：不使用额外的矩阵存储中间结果
4. **保护原始 0**：标记时跳过已经是 0 的位置，避免重复处理

### 复杂度分析
- **时间复杂度**：$O(m \times n \times (m + n))$，对每个 0 都要标记整行整列
- **空间复杂度**：$O(1)$，原地操作

```java
package com.ganten.tethys;

public class Solution {
    private static final int MM = -7349234;  // 标记值，用于标识需要置零的位置

    public void setZeroes(int[][] matrix) {
        // 第一步：找到所有原始的 0，标记其行和列
        for (int i = 0; i < matrix.length; i++) {
            for (int j = 0; j < matrix[0].length; j++) {
                if (matrix[i][j] == 0) {
                    this.setZeroes(matrix, i, j);  // 标记第 i 行和第 j 列
                }
            }
        }
        // 第二步：将所有标记值转换为 0
        for (int i = 0; i < matrix.length; i++) {
            for (int j = 0; j < matrix[0].length; j++) {
                if (matrix[i][j] == MM) {
                    matrix[i][j] = 0;
                }
            }
        }
    }

    // 标记第 i 行和第 j 列的所有非零元素
    public void setZeroes(int[][] matrix, int i, int j) {
        // 标记第 j 列
        for (int i2 = 0; i2 < matrix.length; i2++) {
            if (matrix[i2][j] != 0) {
                matrix[i2][j] = MM;
            }
        }
        // 标记第 i 行
        for (int j2 = 0; j2 < matrix[0].length; j2++) {
            if (matrix[i][j2] != 0) {
                matrix[i][j2] = MM;
            }
        }
    }
}
```

# 128. [Longest Consecutive Sequence](https://leetcode.com/problems/longest-consecutive-sequence/description/)

### 题目描述
给定一个未排序的整数数组 `nums`，找出数字连续的最长序列的长度。要求算法的时间复杂度为 $O(n)$。

例如：`nums = [100,4,200,1,3,2]` → 输出 `4`（连续序列 [1,2,3,4]）

### 核心思想
使用**哈希表**记录每个数字作为起点的最长连续序列长度。遍历数组时，从每个数字向后查找连续的数字，将已访问的数字从哈希表中移除（避免重复计算），并更新起点的最长长度。

### 关键点
1. **哈希表初始化**：所有数字初始值为 1（单独一个数字的长度）
2. **向后扩展**：从当前数字 num 开始，不断查找 num+1, num+2...，累加长度
3. **避免重复**：一旦某个数字被访问并计入序列，就从哈希表中移除（`map.remove(nextNum)`）
4. **更新起点长度**：将累加的长度存回起点位置（`map.put(num, count)`）
5. **剪枝**：若当前数字已被访问（count == 0），跳过

### 复杂度分析
- **时间复杂度**：$O(n)$，每个元素最多被访问两次（一次遍历，一次扩展）
- **空间复杂度**：$O(n)$，哈希表存储所有元素

```java
package com.ganten.tethys;

import java.util.HashMap;

public class Solution {
    public int longestConsecutive(int[] nums) {
        int result = 0;
        // 哈希表：num -> 以 num 为起点的最长连续序列长度
        HashMap<Integer, Integer> map = new HashMap<>();
        
        // 初始化：所有数字的初始长度为 1
        for (int num : nums) {
            map.put(num, 1);
        }
        
        for (int num : nums) {
            int nextNum = num;
            int count = map.getOrDefault(nextNum, 0);
            result = Math.max(count, result);
            
            // 若当前数字已被访问过（被移除），跳过
            if (count == 0) {
                continue;
            }
            
            // 向后扩展，查找连续的数字
            while (true) {
                nextNum++;
                int nextCount = map.getOrDefault(nextNum, 0);
                if (nextCount == 0) {  // 不连续，停止扩展
                    break;
                }
                count = count + nextCount;  // 累加长度
                map.remove(nextNum);        // 移除已访问的数字
                map.put(num, count);        // 更新起点的最长长度
                result = Math.max(count, result);
            }
        }
        return result;
    }

    public static void main(String[] args) {
        Solution solution = new Solution();
        int[] array = new int[] {1, 0, 1, 2};
        int mm = solution.longestConsecutive(array);
        System.out.println(mm);
    }
}
```

# 169. [Majority Element](https://leetcode.com/problems/majority-element/description/)

### 题目描述
给定一个大小为 n 的数组 `nums`，返回其中的多数元素。多数元素是指在数组中出现次数大于 `⌊n/2⌋` 的元素。假设数组非空，且给定的数组总是存在多数元素。

例如：`nums = [3,2,3]` → 输出 `3`

### 核心思想
使用**摩尔投票算法（Boyer-Moore Voting Algorithm）**。维护一个候选人和计数器，遇到相同元素计数+1，遇到不同元素计数-1，计数归零时更换候选人。最终剩下的候选人就是多数元素。

### 关键点
1. **候选人选择**：当 count = 0 时，将当前元素作为新候选人
2. **计数更新**：
   - 遇到与候选人相同的元素：count++
   - 遇到与候选人不同的元素：count--
3. **算法正确性**：由于多数元素出现次数 > n/2，即使与所有其他元素“抵消”后也会剩下
4. **无需验证**：题目保证一定存在多数元素，无需第二次遍历验证

### 执行过程示例
对于 `nums = [2,2,1,1,1,2,2]` 的执行过程：

```
n  result  count  说明
2    2       1    count=0，选择2为候选人
2    2       2    相同，count++
1    2       1    不同，count--
1    2       0    不同，count--
1    1       1    count=0，选择1为候选人
2    1       0    不同，count--
2    2       1    count=0，选择2为候选人
结果  2
```

### 复杂度分析
- **时间复杂度**：$O(n)$，单次遍历
- **空间复杂度**：$O(1)$，只用两个变量

```java
package com.ganten.tethys;

public class Solution {
    public int majorityElement(int[] nums) {
        int result = 0;   // 候选人
        int count = 0;    // 计数器
        
        for (int n : nums) {
            if (count == 0) {
                // 计数器归零，选择新候选人
                result = n;
                count++;
            } else if (n == result) {
                // 遇到相同元素，计数+1
                count++;
            } else {
                // 遇到不同元素，计数-1（抵消）
                count--;
            }
        }
        return result;
    }

    public static void main(String[] args) {
        Solution solution = new Solution();
        int[] array = new int[] {3, 2, 3};
        int mm = solution.majorityElement(array);
        System.out.println(mm);
    }
}

```

# 229. [Majority Element II](https://leetcode.com/problems/majority-element-ii/description/)

### 题目描述
给定一个大小为 n 的整数数组 `nums`，找出所有出现次数大于 `⌊n/3⌋` 的元素。

例如：`nums = [3,2,3]` → 输出 `[3]`
`nums = [1,2]` → 输出 `[1,2]`

### 核心思想
使用**哈希表**统计每个元素的出现次数，然后筛选出次数大于 n/3 的元素。

**注**：也可以使用扩展的摩尔投票算法，维护两个候选人（因为最多只有 2 个元素满足 > n/3），空间复杂度可以优化到 $O(1)$。

### 关键点
1. **阈值计算**：出现次数 > n/3
2. **哈希表统计**：Key 是元素值，Value 是出现次数
3. **结果筛选**：遍历哈希表，收集所有满足条件的元素
4. **数量上限**：最多只有 2 个元素满足条件（因为 3 个或更多无法同时 > n/3）

### 复杂度分析
- **时间复杂度**：$O(n)$，遍历数组一次统计，一次筛选
- **空间复杂度**：$O(n)$，哈希表存储

```java
package com.ganten.tethys;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Map.Entry;

public class Solution {
    public List<Integer> majorityElement(int[] nums) {
        Map<Integer, Integer> hashMap = new HashMap<>();
        
        // 统计每个元素的出现次数
        for (int n : nums) {
            int co = hashMap.getOrDefault(n, 0);
            co++;
            hashMap.put(n, co);
        }
        
        // 筛选出现次数 > n/3 的元素
        List<Integer> arrayList = new ArrayList<>();
        for (Entry<Integer, Integer> entry : hashMap.entrySet()) {
            if (entry.getValue() > nums.length / 3) {
                arrayList.add(entry.getKey());
            }
        }
        return arrayList;
    }

    public static void main(String[] args) {
        Solution solution = new Solution();
        int[] array = new int[] {1,2};
        List<Integer> mm = solution.majorityElement(array);
        System.out.println(mm);
    }
}
```

# 238. [Product of Array Except Self](https://leetcode.com/problems/product-of-array-except-self/description/)

### 题目描述
给定一个数组 `nums`，返回数组 `answer`，其中 `answer[i]` 等于 `nums` 中除了 `nums[i]` 之外其余元素的乘积。不能使用除法，要求时间复杂度 $O(n)$。

例如：`nums = [1,2,3,4]` → 输出 `[24,12,8,6]`

### 核心思想
该解法处理了**包含 0 的特殊情况**：
- **无 0**：直接用总乘积除以当前元素
- **一个 0**：只有0 所在位置的结果为其他元素的乘积，其余位置为 0
- **多个 0**：所有位置的结果都为 0

**注**：更通用的解法是使用左右两次遍历，分别计算左侧乘积和右侧乘积，然后相乘。

### 关键点
1. **统计 0 的数量**：`countOfZero(nums)`
2. **计算非 0 元素的乘积**：`multiply`
3. **分情况处理**：
   - `count == 0`：每个位置 = multiply / nums[i]
   - `count == 1`：只有0 的位置 = multiply，其余 = 0
   - `count >= 2`：所有位置 = 0
4. **避免除法规则**：虽然使用了除法，但这是处理 0 的巧妙方法

### 复杂度分析
- **时间复杂度**：$O(n)$，多次遍历数组
- **空间复杂度**：$O(1)$（不计输出数组）

```java
package com.ganten.tethys;

public class Solution {
    public int[] productExceptSelf(int[] nums) {
        int[] resultArray = new int[nums.length];
        int count = this.countOfZero(nums);  // 统计 0 的数量
        int multiply = 1;  // 所有非 0 元素的乘积
        
        for (int n : nums) {
            if (n != 0)
                multiply *= n;
        }
        
        if (count == 1) {
            // 只有1个0：只有0所在位置的结果为其他元素乘积
            int index = this.indexOfZero(nums);
            resultArray[index] = multiply;
        } else if (count == 0) {
            // 无 0：每个位置用总乘积除以当前元素
            for (int i = 0; i < nums.length; i++) {
                resultArray[i] = multiply / nums[i];
            }
        }
        // count >= 2：所有位置都是 0（默认值）
        return resultArray;
    }

    // 统计 0 的数量
    public int countOfZero(int[] nums) {
        int result = 0;
        for (int num : nums) {
            if (num == 0) {
                result++;
            }
        }
        return result;
    }

    // 找到第一个 0 的索引
    public int indexOfZero(int[] nums) {
        for (int i = 0; i < nums.length; i++) {
            if (nums[i] == 0) {
                return i;
            }
        }
        return -1;
    }

    public static void main(String[] args) {
        Solution solution = new Solution();
        int[] array = new int[] {1, 2, 3, 4};
        int[] mm = solution.productExceptSelf(array);
        System.out.println(mm);
    }
}
```

# 560. [Subarray Sum Equals K](https://leetcode.com/problems/subarray-sum-equals-k/description/)

### 题目描述
给定一个整数数组 `nums` 和一个整数 `k`，请找到该数组中和为 `k` 的连续子数组的个数。

例如：`nums = [1,1,1]`, `k = 2` → 输出 `2`（子数组 [1,1] 出现了 2 次）

### 核心思想
使用**前缀和 + 哈希表**。如果两个位置的前缀和之差等于 k，则这两个位置之间的子数组和就是 k。公式：`sum[i] - sum[j] = k` → `sum[j] = sum[i] - k`

遍历数组时，维护当前前缀和 `sum`，查找是否存在 `sum - k` 的前缀和，如果存在则找到了满足条件的子数组。

### 关键点
1. **前缀和定义**：`sum[i]` 表示 `nums[0...i]` 的和
2. **哈希表存储**：Key 是前缀和，Value 是该前缀和出现的次数
3. **初始化**：`map.put(0, 1)` 处理从索引 0 开始的子数组
4. **计数累加**：每次找到 `sum - k` 时，累加其出现次数（因为可能有多个）
5. **更新哈希表**：将当前前缀和加入/更新哈希表

### 执行过程示例
对于 `nums = [1,1,1]`, `k = 2` 的执行过程：

```
i  num  sum  sum-k  map查找        count  map更新
-   -    0    -2    -              0     {0:1}
0   1    1    -1    不存在         0     {0:1, 1:1}
1   1    2     0    存在，count+=1  1     {0:1, 1:1, 2:1}
2   1    3     1    存在，count+=1  2     {0:1, 1:1, 2:1, 3:1}
结果  2
```

### 复杂度分析
- **时间复杂度**：$O(n)$，单次遍历
- **空间复杂度**：$O(n)$，哈希表存储

```java
import java.util.HashMap;

class Solution {
    public int subarraySum(int[] nums, int k) {
        HashMap<Integer, Integer> map = new HashMap<>();
        map.put(0, 1);  // 前缀和为0出现了一次（处理从索引0开始的子数组）

        int sum = 0, count = 0;
        for (int n : nums) {
            sum += n;  // 计算当前前缀和
            
            // 查找是否存在前缀和为 (sum - k)
            if (map.containsKey(sum - k)) {
                count += map.get(sum - k);  // 累加出现次数
            }
            
            // 更新当前前缀和的出现次数
            map.put(sum, map.getOrDefault(sum, 0) + 1);
        }
        return count;
    }
}
```

# 523. [Continuous Subarray Sum](https://leetcode.com/problems/continuous-subarray-sum/description/)

### 题目描述
给定一个整数数组 `nums` 和一个整数 `k`，判断数组中是否存在长度至少为 2 的连续子数组，其元素总和为 k 的倍数。

例如：`nums = [23,2,4,6,7]`, `k = 6` → 输出 `true`（子数组 [2,4] 的和为 6）

### 核心思想
使用**前缀和的余数**。如果两个位置的前缀和模 k 的余数相同，说明这两个位置之间的子数组和是 k 的倍数。

公式：`(sum[i] - sum[j]) % k = 0` ↔ `sum[i] % k = sum[j] % k`

### 关键点
1. **余数相同原理**：如果 `sum[i] % k == sum[j] % k`，则 `(sum[i] - sum[j]) % k == 0`
2. **长度至少为 2**：不能立即将当前余数加入 set，应该延迟一轮
3. **延迟加入**：使用 `prevMod` 延迟一轮加入 set，确保子数组长度 ≥ 2
4. **初始化**：`set.add(0)` 处理从索引 0 开始的子数组
5. **特殊情况**：k = 0 时需要特殊处理（但题目保证 k > 0）

### 执行过程示例
对于 `nums = [23,2,4,6,7]`, `k = 6` 的执行过程：

```
i  num  sum  mod  prevMod  set检查  set更新
-   -    0    0      0     -       {0}
0   23  23    5      0     5不在   {0}
1    2  25    1      5     1不在   {0,5}
2    4  29    5      1     5在!   返回true
```

### 复杂度分析
- **时间复杂度**：$O(n)$，单次遍历
- **空间复杂度**：$O(\min(n, k))$，余数最多 k 个

```java
import java.util.HashSet;

class Solution {
    public boolean checkSubarraySum(int[] nums, int k) {
        // 存储前缀和的余数
        HashSet<Integer> set = new HashSet<>();
        set.add(0);  // 处理从索引0开始的子数组

        int sum = 0;
        int prevMod = 0;  // 上一个余数，用于延迟一轮加入 set
        
        for (int i = 0; i < nums.length; i++) {
            sum += nums[i];
            int mod = sum % k;  // 当前前缀和的余数

            // 如果当前余数在 set 中出现过，说明找到了满足条件的子数组
            if (set.contains(mod)) {
                return true;
            }

            // 延迟一轮加入 set，确保子数组长度至少为 2
            set.add(prevMod);
            prevMod = mod;
        }
        return false;
    }
}
```

# 525. [Contiguous Array](https://leetcode.com/problems/contiguous-array/description/)

### 题目描述
给定一个二进制数组 `nums`（只包含 0 和 1），找到含有相同数量的 0 和 1 的最长连续子数组的长度。

例如：`nums = [0,1,0]` → 输出 `2`（子数组 [0,1] 或 [1,0]）

### 核心思想
将 0 **看作 -1**，问题转化为找到和为 0 的最长子数组。使用**前缀和 + 哈希表**，记录每个前缀和第一次出现的位置。如果同一个前缀和再次出现，说明两个位置之间的子数组和为 0。

### 关键点
1. **0 → -1 转换**：`sum += (nums[i] == 0 ? -1 : 1)`
2. **前缀和相同**：如果 `sum[i] == sum[j]`，则 `sum[i+1...j] = 0`（即 0 和 1 数量相同）
3. **哈希表存储**：Key 是前缀和，Value 是该前缀和第一次出现的索引
4. **初始化**：`map.put(0, -1)` 处理从索引 0 开始的子数组
5. **计算长度**：`i - map.get(sum)` 计算两个相同前缀和之间的距离

### 执行过程示例
对于 `nums = [0,1,0,1]` 的执行过程：

```
i  num  转sum  map检查         maxLen  map更新
-   -     0    -               0      {0:-1}
0   0    -1    -1不在         0      {0:-1, -1:0}
1   1     0    0在，1-(-1)=2  2      不更新
2   0    -1    -1在，2-0=2    2      不更新
3   1     0    0在，3-(-1)=4 4      不更新
结果  4
```

### 复杂度分析
- **时间复杂度**：$O(n)$，单次遍历
- **空间复杂度**：$O(n)$，哈希表存储

```java
import java.util.HashMap;
import java.util.Map;

class Solution {
    public int findMaxLength(int[] nums) {
        Map<Integer, Integer> map = new HashMap<>();
        map.put(0, -1); // 处理从索引0开始的子数组

        int maxLen = 0;
        int sum = 0;

        for (int i = 0; i < nums.length; i++) {
            // 将 0 看作 -1，1 保持不变
            sum += (nums[i] == 0 ? -1 : 1);

            if (map.containsKey(sum)) {
                // 子数组从上一个相同前缀和之后到当前位置，0和1数量相同
                maxLen = Math.max(maxLen, i - map.get(sum));
            } else {
                // 记录该前缀和第一次出现的位置
                map.put(sum, i);
            }
        }

        return maxLen;

    }
}
```

# 53. [Maximum Subarray](https://leetcode.com/problems/maximum-subarray/description/)

### 题目描述
给定一个整数数组 `nums`，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。

例如：`nums = [-2,1,-3,4,-1,2,1,-5,4]` → 输出 `6`（子数组 [4,-1,2,1]）

### 核心思想
使用**动态规划**。定义 `dp[i]` 表示以 `nums[i]` 结尾的子数组的最大和。对于每个位置，有两种选择：
1. 将当前元素加入之前的子数组：`dp[i-1] + nums[i]`
2. 从当前元素重新开始：`nums[i]`

选择两者中的最大值。

### 关键点
1. **DP 定义**：`dp[i]` = 以 `nums[i]` 结尾的最大子数组和
2. **状态转移**：`dp[i] = max(dp[i-1] + nums[i], nums[i])`
3. **初始化**：`dp[0] = nums[0]`
4. **结果统计**：所有 `dp[i]` 中的最大值
5. **空间优化**：可以用一个变量代替 dp 数组，优化到 $O(1)$ 空间

### 执行过程示例
对于 `nums = [-2,1,-3,4,-1,2,1,-5,4]` 的执行过程：

```
i  nums[i]  dp[i-1]  dp[i]=max(dp[i-1]+nums[i], nums[i])  result
0    -2       -         -2                              -2
1     1      -2         1  (max(-2+1=-1, 1))           1
2    -3       1        -2  (max(1-3=-2, -3))           1
3     4      -2         4  (max(-2+4=2, 4))            4
4    -1       4         3  (max(4-1=3, -1))            4
5     2       3         5  (max(3+2=5, 2))             5
6     1       5         6  (max(5+1=6, 1))             6
7    -5       6         1  (max(6-5=1, -5))            6
8     4       1         5  (max(1+4=5, 4))             6
结果  6
```

### 复杂度分析
- **时间复杂度**：$O(n)$，单次遍历
- **空间复杂度**：$O(n)$，dp 数组（可优化为 $O(1)$）

```java
class Solution {
    public int maxSubArray(int[] nums) {
        int result = Integer.MIN_VALUE;

        // dp[i] 表示 nums[i] 结尾的子数组的最大值
        // dp[i] = max{dp[i-1] + nums[i], nums[i]}
        int[] dp = new int[nums.length];

        for (int i = 0; i < nums.length; i++) {
            // 选择加入之前的子数组或重新开始
            dp[i] = Math.max((i > 0 ? dp[i - 1] : 0) + nums[i], nums[i]);
            result = Math.max(result, dp[i]);
        }
        return result;
    }
}
```

# 42. Trapping Rain Water

```java
class Solution {

    public int trap(int[] heights) {
        int highestIndex = -1;
        int highest = -1;
        for (int i = 0; i < heights.length; i++) {
            if (highest < heights[i]) {
                highest = heights[i];
                highestIndex = i;
            }
        }
        // 左边墙index
        int leftHeight = 0;
        int sumDeep = 0;
        for (int cur = 0; cur < highestIndex; cur++) {
            int curHeight = heights[cur];
            if (leftHeight <= curHeight) {
                leftHeight = curHeight;
            } else {
                sumDeep = sumDeep + leftHeight - curHeight;
            }
        }
        int rightHeight = 0;
        for (int cur = heights.length - 1; cur > highestIndex; cur--) {
            int curHeight = heights[cur];
            if (rightHeight <= curHeight) {
                rightHeight = curHeight;
            } else {
                sumDeep = sumDeep + rightHeight - curHeight;
            }
        }
        return sumDeep;
    }
}
```

# 15. [3Sum](https://leetcode.com/problems/3sum/)

### 题目描述
给定一个整数数组 `nums`，返回所有和为 0 且不重复的三元组。

例如：`nums = [-1,0,1,2,-1,-4]` → 输出 `[[-1,-1,2],[-1,0,1]]`

### 核心思想
使用**排序 + 双指针**。先将数组排序，然后固定一个数 `nums[i]`，用双指针在剩余数组中找另外两个数，使得三数之和为 0。通过跳过重复元素来去重。

### 关键点
1. **排序**：使得可以使用双指针，并且方便去重
2. **固定一个数**：遍历数组，将 `nums[i]` 作为第一个数
3. **双指针查找**：`left = i + 1`, `right = n - 1`，根据和的大小移动指针
4. **去重处理**：
   - 跳过重复的 `nums[i]`
   - 找到答案后跳过重复的 `left` 和 `right`
5. **剪枝优化**：如果 `nums[i] + nums[right-1] + nums[right] < 0`，说明当前 i 无解

### 复杂度分析
- **时间复杂度**：$O(n^2)$，排序 $O(n \log n)$ + 双重循环 $O(n^2)$
- **空间复杂度**：$O(\log n)$，排序所需空间

```java
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;

class Solution {
    public List<List<Integer>> threeSum(int[] nums) {
        Arrays.sort(nums);  // 排序
        List<List<Integer>> resultList = new ArrayList<List<Integer>>();
        
        if (nums.length < 3) {
            return resultList;
        }
        
        for (int i = 0; i < nums.length; i++) {
            int left = i + 1;
            int right = nums.length - 1;

            // 剪枝：如果最大的两个数和当前数相加还 < 0，跳过
            if (nums[i] + nums[right - 1] + nums[right] < 0) {
                continue;
            }

            // 跳过重复的第一个数
            if (i > 0 && nums[i] == nums[i - 1]) {
                continue;
            }

            // 双指针查找
            while (left < right) {
                if (nums[i] + nums[left] + nums[right] > 0) {
                    right--;  // 和太大，右指针左移
                } else if (nums[i] + nums[left] + nums[right] < 0) {
                    left++;   // 和太小，左指针右移
                } else {
                    // 找到一组解
                    ArrayList<Integer> result = new ArrayList<>();
                    result.add(nums[i]);
                    result.add(nums[left]);
                    result.add(nums[right]);
                    resultList.add(result);
                    
                    // 跳过重复的 left
                    int curLeft = nums[left];
                    int curRight = nums[right];
                    while (curLeft == nums[left] && left < right) {
                        left++;
                    }
                    // 跳过重复的 right
                    while (curRight == nums[right] && left < right) {
                        right--;
                    }
                }
            }
        }
        return resultList;
    }
}
```

# 16. [3Sum Closest](https://leetcode.com/problems/3sum-closest/)

### 题目描述
给定一个整数数组 `nums` 和一个目标值 `target`，找出 `nums` 中的三个整数，使得它们的和与 `target` 最接近。返回这三个数的和。

例如：`nums = [-1,2,1,-4]`, `target = 1` → 输出 `2`（-1 + 2 + 1 = 2）

### 核心思想
与 3Sum 问题类似，使用**排序 + 双指针**。不同之处在于，不是查找和等于目标值的三元组，而是维护一个最接近的值，不断更新它。

### 关键点
1. **排序**：使得可以使用双指针
2. **维护最接近值**：`closest` 初始化为 `Integer.MAX_VALUE`
3. **计算当前和**：`cur = nums[i] + nums[left] + nums[right]`
4. **比较距离**：使用 `Math.abs(closest - target)` 和 `Math.abs(cur - target)` 比较
5. **移动指针**：
   - 如果 `cur > target`：right--
   - 如果 `cur < target`：left++
   - 如果 `cur == target`：直接返回（已找到最佳答案）

### 复杂度分析
- **时间复杂度**：$O(n^2)$，排序 + 双重循环
- **空间复杂度**：$O(\log n)$，排序所需空间

```java
import java.util.Arrays;

class Solution {
    public int threeSumClosest(int[] nums, int target) {
        Arrays.sort(nums);  // 排序
        if (nums.length < 3) {
            return 0;
        }
        
        int closest = Integer.MAX_VALUE;  // 最接近的和
        
        for (int i = 0; i < nums.length; i++) {
            int left = i + 1;
            int right = nums.length - 1;

            while (left < right) {
                int cur = nums[i] + nums[left] + nums[right];  // 当前三数之和
                
                // 更新最接近值
                if (Math.abs(closest - target) > Math.abs(cur - target)) {
                    closest = cur;
                }
                
                // 移动指针
                if (cur > target) {
                    right--;  // 和太大，右指针左移
                } else if (cur < target) {
                    left++;   // 和太小，左指针右移
                } else {
                    return target;  // 找到完美匹配，直接返回
                }
            }
        }
        return closest;
    }
}
```

# 66. [Plus One](https://leetcode.com/problems/plus-one/)

### 题目描述
给定一个非负整数的非空数字数组，表示一个非负整数，在该数的基础上加一，返回结果数组。数字按高位到低位存储，最高位数字在数组的首端。

例如：`digits = [1,2,3]` → 输出 `[1,2,4]`
`digits = [9,9,9]` → 输出 `[1,0,0,0]`

### 核心思想
从数组末尾开始，模拟加法进位。使用布尔标志 `flag` 表示是否需要进位。如果最终还有进位，说明需要扩展数组（如 999 + 1 = 1000）。

### 关键点
1. **从后向前遍历**：模拟手算加法
2. **进位标志**：`flag` 表示当前位是否需要加 1
3. **计算结果**：`result = digits[i] + (flag ? 1 : 0)`
4. **更新进位**：`flag = result >= 10`
5. **取余数**：`result %= 10`
6. **扩展数组**：如果遍历结束后 `flag` 还是 `true`，需要创建新数组

### 复杂度分析
- **时间复杂度**：$O(n)$，遍历数组一次
- **空间复杂度**：$O(1)$（不计输出数组）或 $O(n)$（需要扩展时）

```java
class Solution {
    public int[] plusOne(int[] digits) {
        boolean flag = true;  // 进位标志，初始为true（因为要加1）
        
        // 从后向前遍历
        for (int i = digits.length - 1; i >= 0; i--) {
            int result = digits[i] + (flag ? 1 : 0);  // 当前位加上进位
            flag = result >= 10;  // 判断是否需要进位
            result %= 10;         // 取个位数
            digits[i] = result;
        }
        
        // 如果最高位还有进位，需要扩展数组
        if (flag) {
            int[] result = new int[digits.length + 1];
            result[0] = 1;  // 最高位设为1
            System.arraycopy(digits, 0, result, 1, digits.length);  // 复制其余位（都是0）
            return result;
        }
        return digits;
    }
}
```

# 287. [Find the Duplicate Number](https://leetcode.com/problems/find-the-duplicate-number/)

### 题目描述
给定一个包含 n + 1 个整数的数组 `nums`，其数字都在 [1, n] 范围内（包括 1 和 n），可知至少存在一个重复的整数。找出这个重复的数字。

**要求**：
- 不能更改数组
- 只用常量级 $O(1)$ 的空间
- 时间复杂度小于 $O(n^2)$

例如：`nums = [1,3,4,2,2]` → 输出 `2`

### 核心思想
将数组看作**链表**，使用**快慢指针检测环**的方法（Floyd's Cycle Detection）。数组索引作为节点，`nums[i]` 作为指向下一个节点的指针。由于存在重复数字，一定会形成环，环的入口就是重复的数字。

### 关键点
1. **阶段1：检测环**
   - slow 每次移动一步：`slow = nums[slow]`
   - fast 每次移动两步：`fast = nums[nums[fast]]`
   - 它们最终会在环内相遇

2. **阶段2：找到环的入口（重复数）**
   - 从起点和相遇点各放一个指针
   - 每次都移动一步
   - 它们相遇的地方就是环的入口（重复数）

### 执行过程示例
对于 `nums = [1,3,4,2,2]`：
- 索引：`[0,1,2,3,4]`
- 值：  `[1,3,4,2,2]`
- 链表路径：`0 → 1 → 3 → 2 → 4 → 2 → 4 → 2...`（在 2 处形成环）
- 重复数是 **2**

### 复杂度分析
- **时间复杂度**：$O(n)$
- **空间复杂度**：$O(1)$，不需要额外空间

```java
class Solution {
    public int findDuplicate(int[] nums) {
        // 阶段1：检测环，找到 slow 和 fast 的相遇点
        int slow = 0, fast = 0;
        do {
            slow = nums[slow];          // slow 移动一步
            fast = nums[nums[fast]];    // fast 移动两步
            if (slow == fast) {
                break;
            }
        } while (slow != fast);

        // 阶段2：找到环的入口（重复数）
        int n1 = 0, n2 = slow;  // n1 从起点，n2 从相遇点
        while (n1 != n2) {
            n1 = nums[n1];  // 两者都移动一步
            n2 = nums[n2];
        }
        return n1;  // 相遇点就是环的入口（重复数）
    }
}
```

# 268. [Missing Number](https://leetcode.com/problems/missing-number/)

### 题目描述
给定一个包含 [0, n] 中 n 个数的数组 `nums`，找出 [0, n] 这个范围内没有出现在数组中的那个数。

例如：`nums = [3,0,1]` → 输出 `2`
`nums = [0,1]` → 输出 `2`

### 核心思想
使用**数学公式**：计算 [0, n] 的理论总和，然后减去数组元素的实际总和，差值就是缺失的数字。

公式：`理论总和 = (0 + n) × (n + 1) / 2`

### 关键点
1. **理论总和**：等差数列求和公式 `(0 + n) × (n + 1) / 2`
2. **实际总和**：遍历数组累加所有元素
3. **计算差值**：`理论总和 - 实际总和`
4. **特殊情况**：如果差值为 0，说明缺失的是 0（但实际上不会出现）

**替代方法**：使用位运算 XOR，因为 `a ^ a = 0` 且 `a ^ 0 = a`

### 复杂度分析
- **时间复杂度**：$O(n)$，遍历数组一次
- **空间复杂度**：$O(1)$，只用常数额外空间

```java
class Solution {
    public int missingNumber(int[] nums) {
        int sum = 0;
        // 计算数组的实际总和
        for (int num : nums) {
            sum += num;
        }
        
        // 计算 [0, n] 的理论总和
        int expectedSum = (0 + nums.length) * (nums.length + 1) / 2;
        
        // 返回差值（缺失的数字）
        return expectedSum == sum ? 0 : expectedSum - sum;
    }
}
```

# 48. [Rotate Image](https://leetcode.com/problems/rotate-image/)

### 题目描述
给定一个 n × n 的二维矩阵，将其顺时针旋转 90 度。要求原地旋转，不使用额外的矩阵空间。

例如：
```
1 2 3       7 4 1
4 5 6  →   8 5 2
7 8 9       9 6 3
```

### 核心思想
将顺时针旋转 90° 分解为两步：
1. **水平翻转**：将矩阵沿水平中轴翻转（上下对称）
2. **主对角线翻转**：沿主对角线翻转（转置）

### 关键点
1. **第一步：水平翻转**
   - 交换 `matrix[i][j]` 和 `matrix[size-1-i][j]`
   - 只需遍历上半部分行：`i < size/2`
   - 每行的所有列都要交换

2. **第二步：主对角线翻转**
   - 交换 `matrix[i][j]` 和 `matrix[j][i]`
   - 只遍历下三角：`j < i`
   - 实现矩阵转置

### 执行过程示例
```
原始：           水平翻转：      对角线翻转：
1 2 3          7 8 9          7 4 1
4 5 6    →     4 5 6    →     8 5 2
7 8 9          1 2 3          9 6 3
```

### 复杂度分析
- **时间复杂度**：$O(n^2)$，遍历所有元素
- **空间复杂度**：$O(1)$，原地操作

```java
class Solution {
    public void rotate(int[][] matrix) {
        int size = matrix.length;
        
        // 第一步：水平翻转（上下对称交换）
        for (int i = 0; i < size / 2; i++) {
            for (int j = 0; j < size; j++) {
                swap(matrix, i, j, size - 1 - i, j);
            }
        }
        
        // 第二步：沿主对角线翻转（转置）
        for (int i = 0; i < size; i++) {
            for (int j = 0; j < i; j++) {
                swap(matrix, i, j, j, i);
            }
        }
    }

    // 交换两个位置的元素
    private void swap(int[][] matrix, int x1, int y1, int x2, int y2) {
        int temp = matrix[x1][y1];
        matrix[x1][y1] = matrix[x2][y2];
        matrix[x2][y2] = temp;
    }
}
```
