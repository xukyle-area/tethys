# Stack / Monotonic Stack

## 20. [Valid Parentheses](https://leetcode.com/problems/valid-parentheses/)
```java
class Solution {
    public boolean isValid(String s) {
        char[] chars = s.toCharArray();
        LinkedList<Character> linkedList = new LinkedList<>();
        for (char c : chars) {
            if (c == '{' || c == '[' || c == '(') {
                linkedList.push(c);
            } else {
                Character peek = linkedList.peek();
                if (peek == null || Math.abs(c - peek) > 2) return false;
                else linkedList.pop();
            }
        }
        return linkedList.isEmpty();
    }
}
```

## 155. [Min Stack](https://leetcode.com/problems/min-stack/)
```java
class MinStack {

    // 存储正常的栈
    private LinkedList<Integer> stack;
    // 存储截止到当前位置最小的数字
    private LinkedList<Integer> minStack;
    
    public MinStack() {
        stack = new LinkedList<>();
        minStack = new LinkedList<>();
        minStack.push(Integer.MAX_VALUE);
    }

    public void push(int x) {
        stack.push(x);
        minStack.push(Math.min(x, minStack.peek()));
    }

    public void pop() {
        stack.pop();
        minStack.pop();
    }

    public int top() {
        return stack.peek();
    }

    public int getMin() {
        return minStack.peek();
    }
}
```

## 150. [Evaluate Reverse Polish Notation](https://leetcode.com/problems/evaluate-reverse-polish-notation/)
```java
import java.util.LinkedList;

class Solution {

    public int evalRPN(String[] tokens) {

        LinkedList<String> stack = new LinkedList<>();

        for (String token : tokens) {
            if (!token.equals("+") && !token.equals("-") && !token.equals("*") && !token.equals("/")) {
                stack.push(token);
                continue;
            }
            int num1 = Integer.parseInt(stack.pop());
            int num2 = Integer.parseInt(stack.pop());
            int res = 0;
            switch (token) {
                case "+":
                    res = num1 + num2;
                    break;
                case "-":
                    res = num2 - num1;
                    break;
                case "*":
                    res = num1 * num2;
                    break;
                case "/":
                    res = num2 / num1;
                    break;
            }
            stack.push(String.valueOf(res));
        }
        return Integer.parseInt(stack.pop());
    }
}
```

## 394. [Decode String](https://leetcode.com/problems/decode-string/)
```java
class Solution {
    public String decodeString(String s) {
        Stack<Character> stack = new Stack<>();
        char[] chars = s.toCharArray();
        for (int i = 0; i < chars.length; i++) {
            char c = chars[i];
            if ((c >= '0' && c <= '9') || (c >= 'a' && c <= 'z') || c == '[') {
                stack.push(c);
            } else if (c == ']') {
                StringBuilder base = new StringBuilder();
                while (stack.peek() != '[') {
                    base.insert(0, stack.pop());
                }
                stack.pop();
                StringBuilder numc = new StringBuilder();
                while (!stack.empty() && (stack.peek() >= '0' && stack.peek() <= '9')) {
                    numc.insert(0, stack.pop());
                }
                String xx = this.xx(Integer.parseInt(numc.toString()), base.toString());
                for (char c1 : xx.toCharArray()) {
                    stack.push(c1);
                }
            }
        }
        String result = "";
        while (!stack.empty()) {
            result = stack.pop() + result;
        }
        return result;
    }

    public String xx(int n, String base) {
        StringBuilder result = new StringBuilder();
        for (int j = 0; j < n; j++) {
            result.append(base);
        }
        return result.toString();
    }

}
```

## 739. [Daily Temperatures](https://leetcode.com/problems/daily-temperatures/)
```java
class Solution {
    public int[] dailyTemperatures(int[] temperatures) {
        // 栈里的 index 对应的温度值是递减的
        Stack<Integer> stack = new Stack<>();
        int[] result = new int[temperatures.length];

        for (int i = 0; i < temperatures.length; i++) {
            while (!stack.isEmpty() && temperatures[i] > temperatures[stack.peek()]) {
                int idx = stack.pop();
                result[idx] = i - idx;
            }
            stack.push(i);
        }

        return result;
    }
}
```

## 503. [Next Greater Element II](https://leetcode.com/problems/next-greater-element-ii/)

**题目**：给定一个循环数组（最后一个元素的下一个是第一个元素），找出每个元素的下一个更大元素。如果不存在，返回 -1。

**核心思想**：单调递减栈 + 循环数组处理

### 关键点：

1. **循环数组处理**：遍历两遍数组（`i < n * 2`），用 `i % n` 获取实际索引
2. **单调栈**：栈中存储数组下标，栈底到栈顶对应的元素值递减
3. **找到答案时机**：当前元素比栈顶元素大时，栈顶元素找到了答案

### 算法流程：

```
数组: [1, 2, 1]
遍历过程:
i=0: cur=1, 栈空, 入栈 → 栈:[0]
i=1: cur=2, 2>1, 弹出0, result[0]=2, 入栈 → 栈:[1]
i=2: cur=1, 1<2, 入栈 → 栈:[2,1]
i=3: cur=1 (循环), 1<2, 不入栈 → 栈:[2,1]
i=4: cur=2 (循环), 2>1, 弹出2,1, result[2]=2, result[1]=-1(不更新), 不入栈
结果: [2, -1, 2]
```

### 为什么遍历两遍？

- 第一遍：处理能在数组后面找到答案的元素
- 第二遍：处理需要循环到数组前面找答案的元素（如最后几个元素）
- 只在第一遍入栈（`if (i < n)`），避免重复处理

### 复杂度：
- 时间：O(n)，每个元素最多入栈出栈各一次
- 空间：O(n)，栈的空间

```java
import java.util.Arrays;
import java.util.LinkedList;

class Solution {
    public int[] nextGreaterElements(int[] nums) {
        int n = nums.length;
        int[] result = new int[n];
        Arrays.fill(result, -1);  // 初始化为-1（找不到答案的默认值）
        LinkedList<Integer> stack = new LinkedList<>();  // 单调栈，存储索引
        
        // 遍历两遍，模拟循环数组
        for (int i = 0; i < n * 2; i++) {
            if (stack.size() != 0) {
                int cur = nums[i % n];  // 当前元素值
                // 当前元素比栈顶元素大，栈顶元素找到答案
                while (stack.size() != 0 && cur > nums[stack.getFirst()]) {
                    int preIndex = stack.removeFirst();
                    result[preIndex] = cur;
                }
            }
            // 只在第一遍入栈，避免重复
            if (i < n) {
                stack.addFirst(i);
            }
        }

        return result;
    }
}
```

## 42. [Trapping Rain Water](https://leetcode.com/problems/trapping-rain-water/)
```java
class Solution {

    public int trap(int[] heights) {
        int highestIndex = -1;
        int highest = -1;
        for (int i = 0; i < heights.length; i++) {
            if (highest < heights[i]) {
                highest = heights[i];
                highestIndex = i;
            }
        }
        // 左边墙index
        int leftHeight = 0;
        int sumDeep = 0;
        for (int cur = 0; cur < highestIndex; cur++) {
            int curHeight = heights[cur];
            if (leftHeight <= curHeight) {
                leftHeight = curHeight;
            } else {
                sumDeep = sumDeep + leftHeight - curHeight;
            }
        }
        int rightHeight = 0;
        for (int cur = heights.length - 1; cur > highestIndex; cur--) {
            int curHeight = heights[cur];
            if (rightHeight <= curHeight) {
                rightHeight = curHeight;
            } else {
                sumDeep = sumDeep + rightHeight - curHeight;
            }
        }
        return sumDeep;
    }

}
```

## 32. [Longest Valid Parentheses](https://leetcode.com/problems/longest-valid-parentheses/)

**题目**：给定一个只包含 `'('` 和 `')'` 的字符串，找出最长的有效（格式正确且连续）括号子串的长度。

**核心思想**：一维动态规划

### 关键点：

1. **DP定义**：`dp[i]` 表示以 `s[i]` 结尾的最长有效括号长度
2. **两种情况**：
   - `...()` - 直接配对
   - `...))` - 需要跳过中间的有效部分找匹配
3. **以 `'('` 结尾**：不可能是有效括号，`dp[i] = 0`

### 状态转移：

**情况1：`s[i-1]='('` 且 `s[i]=')'`** → 形成 `...()`
```
dp[i] = dp[i-2] + 2
        ^^^^^^^^   ^
        前面的    当前配对
```

**情况2：`s[i-1]=')'` 且 `s[i]=')'`** → 形成 `...))`
- 跳过中间 `dp[i-1]` 长度的有效部分
- 检查 `s[i - dp[i-1] - 1]` 是否是 `'('`
- 如果是，可以匹配

```
dp[i] = dp[i-1] + 2 + dp[i - dp[i-1] - 2]
        ^^^^^^^^   ^   ^^^^^^^^^^^^^^^^^^^
        中间的    当前    前面连续的
        有效长度  配对    有效长度
```

### 算法流程示例：

```
输入: "()(())"
索引:  012345

i=1: ')', '(' + ')' → 情况1
     dp[1] = 0 + 2 = 2

i=2: '(', 跳过

i=3: '(', 跳过

i=4: ')', '(' + ')' → 情况1
     dp[4] = dp[2] + 2 = 0 + 2 = 2

i=5: ')', ')' + ')' → 情况2
     prevLength = dp[4] = 2
     s[5-2-1] = s[2] = '(' ✓ 可以匹配
     dp[5] = 2 + 2 + dp[1] = 2 + 2 + 2 = 6

结果: maxLength = 6
```

### 复杂度：
- 时间：O(n)，单次遍历
- 空间：O(n)，dp 数组

```java
class Solution {
    public int longestValidParentheses(String s) {
        char[] c = s.toCharArray();
        int n = c.length;
        int maxLength = 0;
        int[] dp = new int[n + 1];  // dp[i] = 以 i 结尾的最长有效括号长度
        
        for (int i = 1; i < n; i++) {
            int prevLength = dp[i - 1];
            
            // 以 '(' 结尾不可能是有效括号
            if (c[i] == '(') {
                continue;
            }
            
            if (c[i - 1] == '(') {
                // 情况1: xxxx() - 直接配对
                dp[i] = (i - 2 >= 0 ? dp[i - 2] : 0) + 2;
            } else if (prevLength > 0 && i - prevLength - 1 >= 0 && c[i - prevLength - 1] == '(') {
                // 情况2: yyyy(xxxx)) - 跳过中间有效部分找匹配
                // prevLength 是中间有效部分的长度
                dp[i] = prevLength + 2 + ((i - prevLength - 2) >= 0 ? dp[i - prevLength - 2] : 0);
            }
            
            maxLength = Math.max(maxLength, dp[i]);
        }
        
        return maxLength;
    }
}
```

## 856. [Score of Parentheses](https://leetcode.com/problems/score-of-parentheses/)

### 题目描述
给定一个平衡括号字符串 `s`，按照以下规则计算得分：
- `()` 得 1 分
- `AB` 得 `A + B` 分，其中 A 和 B 是平衡括号字符串
- `(A)` 得 `2 * A` 分，其中 A 是平衡括号字符串

例如：`"()"` 得分为 1，`"(())"` 得分为 2，`"()()"` 得分为 2，`"(()(()))"` 得分为 6。

### 核心思想
使用**栈来跟踪每个嵌套层级的累计分数**。栈中存储的是当前层级的累计得分，遇到 `(` 开始新层（压入 0），遇到 `)` 结束当前层并计算得分累加到上一层。

### 关键点
1. **栈底初始化为 0**：代表最外层的累计分数
2. **遇到 `(`**：压入 0，表示开始新的嵌套层，当前层分数为 0
3. **遇到 `)`**：结束当前层
   - `cur = stack.pop()`：弹出当前层的分数
   - `prev = stack.pop()`：弹出上一层的累计分数
   - `Math.max(cur * 2, 1)`：
     - 若 `cur = 0`（即刚才是 `()`），则得分为 1
     - 若 `cur > 0`（即刚才是 `(A)`），则得分为 `cur * 2`
   - 将新得分加到上一层并压回栈

### 执行过程示例
对于字符串 `"(()(()))"` 的执行过程：

```
字符  栈的变化               说明
初始  [0]                   栈底为最外层累计分数
(     [0, 0]               开始外层括号
(     [0, 0, 0]            开始第一个内层括号
)     [0, 1]               () = 1，累加到外层：0+1=1
(     [0, 1, 0]            开始第二个内层括号
(     [0, 1, 0, 0]         开始更深一层括号
)     [0, 1, 1]            () = 1，累加：0+1=1
)     [0, 3]               (()) = 1*2 = 2，累加：1+2=3
)     [6]                  (()(()))的分数 = 3*2 = 6，累加：0+6=6
结果  6
```

### 复杂度分析
- **时间复杂度**：$O(n)$，遍历字符串一次
- **空间复杂度**：$O(n)$，栈的最大深度等于括号的最大嵌套层数

```java
import java.util.LinkedList;

class Solution {
    public int scoreOfParentheses(String s) {
        LinkedList<Integer> stack = new LinkedList<>();
        stack.push(0);  // 栈底初始化为0，代表最外层累计分数
        
        for (char c : s.toCharArray()) {
            if (c == '(') {
                stack.push(0);  // 开始新的嵌套层，压入0
            } else {
                int cur = stack.pop();   // 当前层的分数
                int prev = stack.pop();  // 上一层的累计分数
                // 如果cur=0说明是()，得1分；否则是(A)，得2*A分
                // 然后累加到上一层
                int newPrev = Math.max(cur * 2, 1) + prev;
                stack.push(newPrev);
            }
        }
        
        return stack.pop();  // 返回最外层的总分
    }
}
```

## 921. [Minimum Add to Make Parentheses Valid](https://leetcode.com/problems/minimum-add-to-make-parentheses-valid/)

### 题目描述
给定一个由 `'('` 和 `')'` 组成的字符串 `s`，你需要添加最少的括号使得括号字符串变为有效。返回需要添加的最少括号数。

例如：
- `"())"` → 添加 1 个 `'('` → 结果为 1
- `"((("` → 添加 3 个 `')'` → 结果为 3
- `"())(("` → 添加 2 个 `'('` 和 2 个 `')'` → 结果为 4

### 核心思想
使用**栈来匹配括号**，将所有无法配对的括号都留在栈中。最终栈的大小就是需要添加的括号数量。

### 关键点
1. **遇到 `'('`**：直接压栈，等待后续的 `')'` 来匹配
2. **遇到 `')'`**：
   - 如果栈顶是 `'('`，配对成功，弹出栈顶
   - 如果栈空或栈顶不是 `'('`，说明这个 `')'` 无法匹配，也压栈
3. **最终栈中剩余的字符**都是无法匹配的，每个都需要添加一个对应的括号

### 执行过程示例
对于字符串 `"()))(("` 的执行过程：

```
字符  栈的变化           说明
初始  []                
(     ['(']             压栈，等待匹配
)     []                栈顶是'('，配对成功，弹出
)     [')']             栈空，无法匹配，压栈
)     [')', ')']        栈顶是')'，无法匹配，压栈
(     [')', ')', '(']   压栈，等待匹配
(     [')', ')', '(', '(']  压栈，等待匹配
结果  栈大小 = 4，需要添加 4 个括号
```

解释：
- 2 个 `')'` 需要在前面添加 2 个 `'('`
- 2 个 `'('` 需要在后面添加 2 个 `')'`

### 复杂度分析
- **时间复杂度**：$O(n)$，遍历字符串一次
- **空间复杂度**：$O(n)$，最坏情况下所有字符都无法匹配

```java
import java.util.LinkedList;

class Solution {
    public int minAddToMakeValid(String s) {
        LinkedList<Character> stack = new LinkedList<>();

        for (char c : s.toCharArray()) {
            if (c == '(') {
                stack.push(c);  // '(' 压栈，等待匹配
            }
            if (c == ')') {
                // 如果栈顶是 '('，配对成功，弹出
                if (stack.size() != 0 && stack.getFirst() == '(') {
                    stack.pop();
                } else {
                    // 否则 ')' 无法匹配，也压栈
                    stack.push(c);
                }
            }
        }
        // 栈中剩余的都是无法匹配的括号
        return stack.size();
    }
}
```
