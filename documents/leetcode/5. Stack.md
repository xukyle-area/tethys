# Stack / Monotonic Stack

## 20. [Valid Parentheses](https://leetcode.com/problems/valid-parentheses/)
```java
class Solution {
    public boolean isValid(String s) {
        char[] chars = s.toCharArray();
        LinkedList<Character> linkedList = new LinkedList<>();
        for (char c : chars) {
            if (c == '{' || c == '[' || c == '(') {
                linkedList.push(c);
            } else {
                Character peek = linkedList.peek();
                if (peek == null || Math.abs(c - peek) > 2) return false;
                else linkedList.pop();
            }
        }
        return linkedList.isEmpty();
    }
}
```

## 155. [Min Stack](https://leetcode.com/problems/min-stack/)
```java
class MinStack {

    // 存储正常的栈
    private LinkedList<Integer> stack;
    // 存储截止到当前位置最小的数字
    private LinkedList<Integer> minStack;
    
    public MinStack() {
        stack = new LinkedList<>();
        minStack = new LinkedList<>();
        minStack.push(Integer.MAX_VALUE);
    }

    public void push(int x) {
        stack.push(x);
        minStack.push(Math.min(x, minStack.peek()));
    }

    public void pop() {
        stack.pop();
        minStack.pop();
    }

    public int top() {
        return stack.peek();
    }

    public int getMin() {
        return minStack.peek();
    }
}
```

## 150. [Evaluate Reverse Polish Notation](https://leetcode.com/problems/evaluate-reverse-polish-notation/)
```java
import java.util.LinkedList;

class Solution {

    public int evalRPN(String[] tokens) {

        LinkedList<String> stack = new LinkedList<>();

        for (String token : tokens) {
            if (!token.equals("+") && !token.equals("-") && !token.equals("*") && !token.equals("/")) {
                stack.push(token);
                continue;
            }
            int num1 = Integer.parseInt(stack.pop());
            int num2 = Integer.parseInt(stack.pop());
            int res = 0;
            switch (token) {
                case "+":
                    res = num1 + num2;
                    break;
                case "-":
                    res = num2 - num1;
                    break;
                case "*":
                    res = num1 * num2;
                    break;
                case "/":
                    res = num2 / num1;
                    break;
            }
            stack.push(String.valueOf(res));
        }
        return Integer.parseInt(stack.pop());
    }
}
```

## 394. [Decode String](https://leetcode.com/problems/decode-string/)
```java
class Solution {
    public String decodeString(String s) {
        Stack<Character> stack = new Stack<>();
        char[] chars = s.toCharArray();
        for (int i = 0; i < chars.length; i++) {
            char c = chars[i];
            if ((c >= '0' && c <= '9') || (c >= 'a' && c <= 'z') || c == '[') {
                stack.push(c);
            } else if (c == ']') {
                StringBuilder base = new StringBuilder();
                while (stack.peek() != '[') {
                    base.insert(0, stack.pop());
                }
                stack.pop();
                StringBuilder numc = new StringBuilder();
                while (!stack.empty() && (stack.peek() >= '0' && stack.peek() <= '9')) {
                    numc.insert(0, stack.pop());
                }
                String xx = this.xx(Integer.parseInt(numc.toString()), base.toString());
                for (char c1 : xx.toCharArray()) {
                    stack.push(c1);
                }
            }
        }
        String result = "";
        while (!stack.empty()) {
            result = stack.pop() + result;
        }
        return result;
    }

    public String xx(int n, String base) {
        StringBuilder result = new StringBuilder();
        for (int j = 0; j < n; j++) {
            result.append(base);
        }
        return result.toString();
    }

}
```

## 739. [Daily Temperatures](https://leetcode.com/problems/daily-temperatures/)
```java
class Solution {
    public int[] dailyTemperatures(int[] temperatures) {
        // 栈里的 index 对应的温度值是递减的
        Stack<Integer> stack = new Stack<>();
        int[] result = new int[temperatures.length];

        for (int i = 0; i < temperatures.length; i++) {
            while (!stack.isEmpty() && temperatures[i] > temperatures[stack.peek()]) {
                int idx = stack.pop();
                result[idx] = i - idx;
            }
            stack.push(i);
        }

        return result;
    }
}
```

## 503. [Next Greater Element II](https://leetcode.com/problems/next-greater-element-ii/)

**题目**：给定一个循环数组（最后一个元素的下一个是第一个元素），找出每个元素的下一个更大元素。如果不存在，返回 -1。

**核心思想**：单调递减栈 + 循环数组处理

### 关键点：

1. **循环数组处理**：遍历两遍数组（`i < n * 2`），用 `i % n` 获取实际索引
2. **单调栈**：栈中存储数组下标，栈底到栈顶对应的元素值递减
3. **找到答案时机**：当前元素比栈顶元素大时，栈顶元素找到了答案

### 算法流程：

```
数组: [1, 2, 1]
遍历过程:
i=0: cur=1, 栈空, 入栈 → 栈:[0]
i=1: cur=2, 2>1, 弹出0, result[0]=2, 入栈 → 栈:[1]
i=2: cur=1, 1<2, 入栈 → 栈:[2,1]
i=3: cur=1 (循环), 1<2, 不入栈 → 栈:[2,1]
i=4: cur=2 (循环), 2>1, 弹出2,1, result[2]=2, result[1]=-1(不更新), 不入栈
结果: [2, -1, 2]
```

### 为什么遍历两遍？

- 第一遍：处理能在数组后面找到答案的元素
- 第二遍：处理需要循环到数组前面找答案的元素（如最后几个元素）
- 只在第一遍入栈（`if (i < n)`），避免重复处理

### 复杂度：
- 时间：O(n)，每个元素最多入栈出栈各一次
- 空间：O(n)，栈的空间

```java
import java.util.Arrays;
import java.util.LinkedList;

class Solution {
    public int[] nextGreaterElements(int[] nums) {
        int n = nums.length;
        int[] result = new int[n];
        Arrays.fill(result, -1);  // 初始化为-1（找不到答案的默认值）
        LinkedList<Integer> stack = new LinkedList<>();  // 单调栈，存储索引
        
        // 遍历两遍，模拟循环数组
        for (int i = 0; i < n * 2; i++) {
            if (stack.size() != 0) {
                int cur = nums[i % n];  // 当前元素值
                // 当前元素比栈顶元素大，栈顶元素找到答案
                while (stack.size() != 0 && cur > nums[stack.getFirst()]) {
                    int preIndex = stack.removeFirst();
                    result[preIndex] = cur;
                }
            }
            // 只在第一遍入栈，避免重复
            if (i < n) {
                stack.addFirst(i);
            }
        }

        return result;
    }
}
```

## 42. [Trapping Rain Water](https://leetcode.com/problems/trapping-rain-water/)
```java
class Solution {

    public int trap(int[] heights) {
        int highestIndex = -1;
        int highest = -1;
        for (int i = 0; i < heights.length; i++) {
            if (highest < heights[i]) {
                highest = heights[i];
                highestIndex = i;
            }
        }
        // 左边墙index
        int leftHeight = 0;
        int sumDeep = 0;
        for (int cur = 0; cur < highestIndex; cur++) {
            int curHeight = heights[cur];
            if (leftHeight <= curHeight) {
                leftHeight = curHeight;
            } else {
                sumDeep = sumDeep + leftHeight - curHeight;
            }
        }
        int rightHeight = 0;
        for (int cur = heights.length - 1; cur > highestIndex; cur--) {
            int curHeight = heights[cur];
            if (rightHeight <= curHeight) {
                rightHeight = curHeight;
            } else {
                sumDeep = sumDeep + rightHeight - curHeight;
            }
        }
        return sumDeep;
    }

}
```

## 32. [Longest Valid Parentheses](https://leetcode.com/problems/longest-valid-parentheses/)

**题目**：给定一个只包含 `'('` 和 `')'` 的字符串，找出最长的有效（格式正确且连续）括号子串的长度。

**核心思想**：一维动态规划

### 关键点：

1. **DP定义**：`dp[i]` 表示以 `s[i]` 结尾的最长有效括号长度
2. **两种情况**：
   - `...()` - 直接配对
   - `...))` - 需要跳过中间的有效部分找匹配
3. **以 `'('` 结尾**：不可能是有效括号，`dp[i] = 0`

### 状态转移：

**情况1：`s[i-1]='('` 且 `s[i]=')'`** → 形成 `...()`
```
dp[i] = dp[i-2] + 2
        ^^^^^^^^   ^
        前面的    当前配对
```

**情况2：`s[i-1]=')'` 且 `s[i]=')'`** → 形成 `...))`
- 跳过中间 `dp[i-1]` 长度的有效部分
- 检查 `s[i - dp[i-1] - 1]` 是否是 `'('`
- 如果是，可以匹配

```
dp[i] = dp[i-1] + 2 + dp[i - dp[i-1] - 2]
        ^^^^^^^^   ^   ^^^^^^^^^^^^^^^^^^^
        中间的    当前    前面连续的
        有效长度  配对    有效长度
```

### 算法流程示例：

```
输入: "()(())"
索引:  012345

i=1: ')', '(' + ')' → 情况1
     dp[1] = 0 + 2 = 2

i=2: '(', 跳过

i=3: '(', 跳过

i=4: ')', '(' + ')' → 情况1
     dp[4] = dp[2] + 2 = 0 + 2 = 2

i=5: ')', ')' + ')' → 情况2
     prevLength = dp[4] = 2
     s[5-2-1] = s[2] = '(' ✓ 可以匹配
     dp[5] = 2 + 2 + dp[1] = 2 + 2 + 2 = 6

结果: maxLength = 6
```

### 复杂度：
- 时间：O(n)，单次遍历
- 空间：O(n)，dp 数组

```java
class Solution {
    public int longestValidParentheses(String s) {
        char[] c = s.toCharArray();
        int n = c.length;
        int maxLength = 0;
        int[] dp = new int[n + 1];  // dp[i] = 以 i 结尾的最长有效括号长度
        
        for (int i = 1; i < n; i++) {
            int prevLength = dp[i - 1];
            
            // 以 '(' 结尾不可能是有效括号
            if (c[i] == '(') {
                continue;
            }
            
            if (c[i - 1] == '(') {
                // 情况1: xxxx() - 直接配对
                dp[i] = (i - 2 >= 0 ? dp[i - 2] : 0) + 2;
            } else if (prevLength > 0 && i - prevLength - 1 >= 0 && c[i - prevLength - 1] == '(') {
                // 情况2: yyyy(xxxx)) - 跳过中间有效部分找匹配
                // prevLength 是中间有效部分的长度
                dp[i] = prevLength + 2 + ((i - prevLength - 2) >= 0 ? dp[i - prevLength - 2] : 0);
            }
            
            maxLength = Math.max(maxLength, dp[i]);
        }
        
        return maxLength;
    }
}
```

## 856. [Score of Parentheses](https://leetcode.com/problems/score-of-parentheses/)
```java

```

## 921. [Minimum Add to Make Parentheses Valid](https://leetcode.com/problems/minimum-add-to-make-parentheses-valid/)
```java

```
