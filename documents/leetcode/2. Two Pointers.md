# 125. [Valid Palindrome](https://leetcode.com/problems/valid-palindrome/description/)

### 题目描述
给定一个字符串 `s`，判断它是否是回文串。只考虑字母和数字字符，忽略字母的大小写。

例如：`"A man, a plan, a canal: Panama"` → 输出 `true`

### 核心思想
使用**双指针**从两端向中间移动，跳过非字母数字字符，比较对应位置的字符（转换为小写）是否相同。

### 关键点
1. **双指针**：`left` 从左开始，`right` 从右开始
2. **跳过无效字符**：移动指针直到遇到字母或数字
3. **大小写转换**：ASCII 码差值是 32（小写字母 = 大写字母 + 32）
4. **结束条件**：`left > right` 表示已检查完所有字符

### 复杂度分析
- **时间复杂度**：$O(n)$，每个字符最多被访问一次
- **空间复杂度**：$O(1)$，只用常数额外空间

```java
package com.ganten.tethys;

public class Solution {
    public boolean isPalindrome(String s) {
        int left = 0;
        int right = s.length() - 1;
        
        while (true) {
            // 移动 left 直到遇到字母或数字
            while (left < s.length() && !this.isLetter(s.charAt(left))) left++;
            
            // 移动 right 直到遇到字母或数字
            while (right >= 0 && !this.isLetter(s.charAt(right))) right--;
            
            // 指针相遇，检查完毕
            if (left > right) break;
            
            // 比较字符（转换为小写）
            if (this.toLowCase(s.charAt(left)) != this.toLowCase(s.charAt(right))) return false;
            left++;
            right--;
        }
        return true;
    }

    // 判断是否是字母或数字
    private boolean isLetter(char c) {
        return ('a' <= c && 'z' >= c) || ('A' <= c && 'Z' >= c) || ('0' <= c && '9' >= c);
    }

    // 转换为小写（小写 ASCII = 大写 ASCII + 32）
    private char toLowCase(char c) {
        if ('A' <= c && 'Z' >= c) return (char) (c + 32);
        return c;
    }

    public static void main(String[] args) {
        Solution solution = new Solution();
        boolean mm = solution.isPalindrome("A man, a plan, a canal: Panama");
        System.out.println(mm);
    }
}

```

# 344. [Reverse String](https://leetcode.com/problems/reverse-string/description/)

### 题目描述
编写一个函数，其作用是将输入的字符数组反转。要求原地修改，不使用额外空间。

例如：`['h','e','l','l','o']` → `['o','l','l','e','h']`

### 核心思想
使用**双指针**从两端向中间移动，交换对应位置的字符。

### 关键点
1. **双指针**：`left` 从 0 开始，`right` 从 `length-1` 开始
2. **交换元素**：交换 `s[left]` 和 `s[right]`
3. **移动指针**：`left++`, `right--`
4. **结束条件**：`left < right`

**注**：代码中有个小错误，`right++` 和 `left++` 的顺序反了，应该是 `left++, right--`。

### 复杂度分析
- **时间复杂度**：$O(n)$，遍历半个数组
- **空间复杂度**：$O(1)$，原地修改

```java
package com.ganten.tethys;

public class Solution {
    public void reverseString(char[] s) {
        int left = 0;
        int right = s.length - 1;
        while (left < right) {
            // 交换左右两端的字符
            this.swap(s, left, right);  // 注：原代码参数顺序有误
            left++;
            right--;
        }
    }

    public void swap(char[] s, int i, int j) {
        char temp = s[i];
        s[i] = s[j];
        s[j] = temp;
    }
}
```

# 680. [Valid Palindrome II](https://leetcode.com/problems/valid-palindrome-ii/description/)

### 题目描述
给定一个非空字符串 `s`，最多可以删除一个字符，判断是否能成为回文串。

例如：`"aba"` → 输出 `true`
`"abca"` → 输出 `true`（删除 'c'）

### 核心思想
使用**双指针 + 递归**。当遇到不匹配的字符时，尝试删除左边或右边的字符，看剩余部分是否是回文。

### 关键点
1. **带限制的递归**：参数 `i` 表示还可以删除的次数（1次）
2. **遇到不匹配**：分两种情况递归
   - 删除左边字符：`validPalindrome(s.substring(left + 1, right + 1), i - 1)`
   - 删除右边字符：`validPalindrome(s.substring(left, right), i - 1)`
3. **删除次数用尽**：`i == 0` 时不能再删除，返回 `false`
4. **匹配成功**：所有字符匹配，返回 `true`

### 复杂度分析
- **时间复杂度**：$O(n)$，最多递归两次
- **空间复杂度**：$O(n)$，递归栈和子字符串空间

```java
package com.ganten.tethys;

public class Solution {
    public boolean validPalindrome(String s) {
        return validPalindrome(s, 1);  // 初始可以删除 1 次
    }

    public boolean validPalindrome(String s, int i) {
        int left = 0;
        int right = s.length() - 1;
        
        while (left < right) {
            if (s.charAt(left) == s.charAt(right)) {
                // 字符匹配，继续检查
                left++;
                right--;
            } else {
                // 字符不匹配
                if (i == 0) {
                    // 已经删除过一次，无法再删除
                    return false;
                }
                // 尝试删除左边或右边的字符
                return this.validPalindrome(s.substring(left + 1, right + 1), i - 1)  // 删除左边
                        || this.validPalindrome(s.substring(left, right), i - 1);     // 删除右边
            }
        }
        return true;
    }
}
```

# 5. [Longest Palindromic Substring](https://leetcode.com/problems/longest-palindromic-substring/description/)

### 题目描述
给定一个字符串 `s`，找到 `s` 中最长的回文子串。

例如：`"babad"` → 输出 `"bab"` 或 `"aba"`

### 核心思想
使用**中心扩展法**。遍历每个位置作为回文中心，向两边扩展寻找最长回文。需要考虑两种情况：奇数长度（单个字符为中心）和偶数长度（两个字符为中心）。

### 关键点
1. **中心扩展**：从中心向两边扩展，直到不是回文
2. **两种情况**：
   - 奇数长度：`checkPalindrome(chars, i, i)`
   - 偶数长度：`checkPalindrome(chars, i, i + 1)`
3. **记录最长**：维护 `resultStart` 和 `resultLen` 记录最长回文的位置和长度
4. **扩展条件**：`left >= 0 && right < length && chars[left] == chars[right]`

### 复杂度分析
- **时间复杂度**：$O(n^2)$，每个中心扩展最多 $O(n)$
- **空间复杂度**：$O(1)$，只用常数额外空间

```java
class Solution {
    private int resultStart = 0;  // 最长回文的起始位置
    private int resultLen = 0;    // 最长回文的长度

    public String longestPalindrome(String s) {
        if (s == null || s.length() < 2) return s;
        
        char[] chars = s.toCharArray();

        // 遍历每个位置作为中心
        for (int i = 0; i < chars.length; i++) {
            checkPalindrome(chars, i, i);      // 奇数长度回文：以 i 为中心
            checkPalindrome(chars, i, i + 1);  // 偶数长度回文：以 i 和 i+1 为中心
        }

        return s.substring(resultStart, resultStart + resultLen);
    }

    // 从中心向两边扩展，检查回文
    private void checkPalindrome(char[] chars, int left, int right) {
        // 向两边扩展，直到不匹配或越界
        while (left >= 0 && right < chars.length && chars[left] == chars[right]) {
            left--;
            right++;
        }
        
        // 计算回文长度（注意：退出时 left 和 right 已经越界或不匹配）
        int len = right - left - 1;
        
        // 更新最长回文
        if (len > resultLen) {
            resultLen = len;
            resultStart = left + 1;
        }
    }
}
```

# 11. [Container With Most Water](https://leetcode.com/problems/container-with-most-water/description/)

### 题目描述
给定 n 个非负整数 `height`，每个数代表坐标中的一个点的高度。找出其中的两条线，使得它们与 x 轴共同构成的容器可以容纳最多的水。

例如：`height = [1,8,6,2,5,4,8,3,7]` → 输出 `49`

### 核心思想
使用**双指针**从两端向中间移动。容器的面积由较短的那条边决定，每次移动较短的那一边，因为移动较长的边不可能增大面积。

### 关键点
1. **面积计算**：`面积 = 宽度 × 高度 = (right - left) × min(height[left], height[right])`
2. **移动策略**：移动较短的边
   - 如果 `height[left] < height[right]`：`left++`
   - 否则：`right--`
3. **贪心选择**：每步都选择可能增大面积的移动
4. **维护最大值**：不断更新全局最大面积

### 为什么移动较短的边？
- 面积由较短的边决定
- 移动较长的边，宽度减小，高度不变或减小，面积一定减小
- 移动较短的边，虽然宽度减小，但高度可能增大，有机会增大面积

### 复杂度分析
- **时间复杂度**：$O(n)$，双指针遍历一次
- **空间复杂度**：$O(1)$，只用常数额外空间

```java
package com.ganten.tethys;

class Solution {
    public int maxArea(int[] height) {
        int left = 0;
        int right = height.length - 1;
        int max = 0;
        
        while (left < right) {
            // 计算当前面积：宽度 × 较短的高度
            int cur = (right - left) * Math.min(height[left], height[right]);
            max = Math.max(max, cur);
            
            // 移动较短的边
            if (height[left] > height[right]) {
                right--;
            } else {
                left++;
            }
        }
        return max;
    }
}
```

# 15. [3Sum](https://leetcode.com/problems/3sum/description/)
```java
package com.ganten.tethys;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;

class Solution {
    public List<List<Integer>> threeSum(int[] nums) {
        Arrays.sort(nums);
        List<List<Integer>> resultList = new ArrayList<List<Integer>>();
        if (nums.length < 3) {
            return resultList;
        }
        for (int i = 0; i < nums.length; i++) {
            int left = i + 1;
            int right = nums.length - 1;

            if (nums[i] + nums[right - 1] + nums[right] < 0) {
                continue;
            }

            if (i > 0 && nums[i] == nums[i - 1]) {
                continue;
            }

            while (left < right) {
                if (nums[i] + nums[left] + nums[right] > 0) {
                    right--;
                } else if (nums[i] + nums[left] + nums[right] < 0) {
                    left++;
                } else {
                    ArrayList<Integer> result = new ArrayList<>();
                    result.add(nums[i]);
                    result.add(nums[left]);
                    result.add(nums[right]);
                    resultList.add(result);
                    int curLeft = nums[left];
                    int curRight = nums[right];
                    while (curLeft == nums[left] && left < right) {
                        left++;
                    }

                    while (curRight == nums[right] && left < right) {
                        right--;
                    }
                }
            }
        }
        return resultList;
    }
}
```

# 16. [3Sum Closest](https://leetcode.com/problems/3sum-closest/description/)
```java
package com.ganten.tethys;

import java.util.Arrays;

class Solution {
    public int threeSumClosest(int[] nums, int tagret) {
        Arrays.sort(nums);
        if (nums.length < 3) {
            return 0;
        }
        int closet = Integer.MAX_VALUE;
        for (int i = 0; i < nums.length; i++) {
            int left = i + 1;
            int right = nums.length - 1;

            while (left < right) {
                int cur = nums[i] + nums[left] + nums[right];
                if (Math.abs(closet - tagret) > Math.abs(cur - tagret)) {
                    closet = cur;
                }
                if (nums[i] + nums[left] + nums[right] > tagret) {
                    right--;
                } else if (nums[i] + nums[left] + nums[right] < tagret) {
                    left++;
                } else {
                    return tagret;
                }
            }
        }
        return closet;
    }
}
```

# 167. [Two Sum II](https://leetcode.com/problems/two-sum-ii-input-array-is-sorted/description/)

### 题目描述
给定一个已按照非递减顺序排列的整数数组 `numbers`，找到两个数使得它们相加之和等于目标数 `target`。返回这两个数的下标（从 1 开始）。

例如：`numbers = [2,7,11,15]`, `target = 9` → 输出 `[1,2]`

### 核心思想
利用数组已排序的特点，使用**双指针**从两端向中间移动。根据和与目标的大小关系调整指针。

### 关键点
1. **双指针**：`low` 从左开始，`high` 从右开始
2. **移动策略**：
   - 如果 `sum == target`：找到答案，返回（注意 +1）
   - 如果 `sum < target`：需要更大的数，`low++`
   - 如果 `sum > target`：需要更小的数，`high--`
3. **下标转换**：题目要求从 1 开始，所以返回时要 +1

### 复杂度分析
- **时间复杂度**：$O(n)$，双指针遍历一次
- **空间复杂度**：$O(1)$，只用常数额外空间

```java
class Solution {
    public int[] twoSum(int[] numbers, int target) {
        int low = 0, high = numbers.length - 1;
        
        while (low < high) {
            int sum = numbers[low] + numbers[high];
            
            if (sum == target) {
                // 找到答案，返回下标（从 1 开始）
                return new int[]{low + 1, high + 1};
            } else if (sum < target) {
                // 和太小，左指针右移
                ++low;
            } else {
                // 和太大，右指针左移
                --high;
            }
        }
        return new int[]{-1, -1};  // 未找到
    }
}
```

# 283. [Move Zeroes](https://leetcode.com/problems/move-zeroes/description/)

### 题目描述
给定一个数组 `nums`，将所有 0 移动到数组的末尾，同时保持非零元素的相对顺序。要求原地操作。

例如：`[0,1,0,3,12]` → `[1,3,12,0,0]`

### 核心思想
使用**快慢指针**。`slow` 指针跟踪下一个非零元素应该放置的位置，`fast` 指针遍历数组。遇到非零元素就移动到 `slow` 位置，最后将剩余位置填充 0。

### 关键点
1. **快慢指针**：
   - `slow`：下一个非零元素的位置
   - `fast`：遍历数组的指针
2. **处理逻辑**：
   - 遇到 0：跳过
   - 遇到非 0：移动到 `slow` 位置，`slow++`
3. **填充 0**：遍历结束后，从 `slow` 到末尾填充 0

### 复杂度分析
- **时间复杂度**：$O(n)$，遍历数组两次
- **空间复杂度**：$O(1)$，原地操作

```java
class Solution {
    public void moveZeroes(int[] nums) {
        int slow = 0;  // 下一个非零元素的位置
        
        // 第一遍：将所有非零元素移动到前面
        for (int fast = 0; fast < nums.length; fast++) {
            if (nums[fast] == 0) {
                continue;  // 跳过零元素
            }
            nums[slow] = nums[fast];  // 移动非零元素
            slow++;
        }
        
        // 第二遍：将剩余位置填充 0
        for (; slow < nums.length; slow++) {
            nums[slow] = 0;
        }
    }
}
```

# 75. [Sort Colors](https://leetcode.com/problems/sort-colors/description/)

### 题目描述
给定一个包含红色、白色和蓝色，共 n 个元素的数组 `nums`，原地对它们进行排序，使得相同颜色的元素相邻，并按照红色、白色、蓝色顺序排列。使用整数 0、1 和 2 分别表示红色、白色和蓝色。

例如：`[2,0,2,1,1,0]` → `[0,0,1,1,2,2]`

### 核心思想
使用**三指针（荷兰国旗问题）**。维护三个指针：`left` 指向下一个 0 应该放置的位置，`right` 指向下一个 2 应该放置的位置，`curr` 用于遍历数组。

### 关键点
1. **三个区域**：
   - `[0, left)` 全是 0
   - `[left, curr)` 全是 1
   - `(right, n-1]` 全是 2
2. **处理逻辑**：
   - `nums[curr] == 0`：与 `left` 交换，`left++`, `curr++`
   - `nums[curr] == 1`：`curr++`
   - `nums[curr] == 2`：与 `right` 交换，`right--`（注意：`curr` 不动）
3. **为什么交换 2 后 curr 不动？**
   - 因为从 `right` 交换过来的元素还未检查

### 复杂度分析
- **时间复杂度**：$O(n)$，单次遍历
- **空间复杂度**：$O(1)$，原地排序

```java
class Solution {
    public void sortColors(int[] nums) {
        int left = 0;               // 下一个 0 的位置
        int right = nums.length - 1; // 下一个 2 的位置
        int curr = 0;               // 当前遍历指针

        while (curr <= right) {
            if (nums[curr] == 0) {
                // 遇到 0，交换到最左边
                swap(nums, left, curr);
                left++;
                curr++;
            } else if (nums[curr] == 2) {
                // 遇到 2，交换到最右边
                swap(nums, curr, right);
                right--;
                // 注意：curr 不动，因为交换过来的元素还未检查
            } else {
                // 遇到 1，保持不动
                curr++;
            }
        }
    }

    private void swap(int[] nums, int i, int j) {
        int temp = nums[i];
        nums[i] = nums[j];
        nums[j] = temp;
    }
}
```

# 26. [Remove Duplicates from Sorted Array](https://leetcode.com/problems/remove-duplicates-from-sorted-array/description/)

### 题目描述
给定一个排序数组 `nums`，原地删除重复出现的元素，使得每个元素只出现一次，返回删除后数组的新长度。

例如：`[1,1,2]` → 返回 `2`，数组前 2 个元素为 `[1,2]`

### 核心思想
使用**快慢指针**。`slow` 指向下一个不重复元素应该放置的位置，`fast` 遍历数组。只有当 `nums[fast] != nums[slow-1]` 时才移动元素。

### 关键点
1. **快慢指针**：
   - `slow`：下一个不重复元素的位置（从 1 开始）
   - `fast`：遍历数组的指针（从 1 开始）
2. **去重判断**：比较 `nums[fast]` 和 `nums[slow-1]`
   - 相同：重复，跳过
   - 不同：不重复，移动到 `slow` 位置
3. **初始化**：从索引 1 开始（第一个元素不用处理）

### 复杂度分析
- **时间复杂度**：$O(n)$，单次遍历
- **空间复杂度**：$O(1)$，原地操作

```java
class Solution {
    public int removeDuplicates(int[] nums) {
        int slow = 1;  // 下一个不重复元素的位置
        int fast = 1;  // 遍历指针
        
        while (fast < nums.length) {
            if (nums[fast] == nums[slow - 1]) {
                // 重复元素，跳过
                fast++;
            } else {
                // 不重复元素，移动到 slow 位置
                nums[slow++] = nums[fast++];
            }
        }
        return slow;  // 返回新长度
    }
}
```

# 27. [Remove Element](https://leetcode.com/problems/remove-element/description/)

### 题目描述
给定一个数组 `nums` 和一个值 `val`，原地移除所有数值等于 `val` 的元素，返回移除后数组的新长度。

例如：`nums = [3,2,2,3]`, `val = 3` → 返回 `2`，数组前 2 个元素为 `[2,2]`

### 核心思想
使用**快慢指针**。`slow` 指向下一个非 `val` 元素应该放置的位置，`fast` 遍历数组。遇到非 `val` 的元素就移动到 `slow` 位置。

### 关键点
1. **快慢指针**：
   - `slow`：下一个非 val 元素的位置
   - `fast`：遍历数组的指针
2. **处理逻辑**：
   - `nums[fast] == val`：跳过
   - `nums[fast] != val`：移动到 `slow` 位置
3. **类似 283 题**：与 Move Zeroes 逻辑相同

### 复杂度分析
- **时间复杂度**：$O(n)$，单次遍历
- **空间复杂度**：$O(1)$，原地操作

```java
class Solution {
    public int removeElement(int[] nums, int val) {
        int slow = 0;  // 下一个非 val 元素的位置
        int fast = 0;  // 遍历指针
        
        while (fast < nums.length) {
            if (nums[fast] == val) {
                // 遇到 val，跳过
                fast++;
                continue;
            }
            // 遇到非 val，移动到 slow 位置
            nums[slow++] = nums[fast++];
        }
        return slow;  // 返回新长度
    }
}
```

# 80. [Remove Duplicates II](https://leetcode.com/problems/remove-duplicates-from-sorted-array-ii/description/)

### 题目描述
给定一个排序数组 `nums`，原地删除重复出现的元素，使得每个元素最多出现两次，返回删除后数组的新长度。

例如：`[1,1,1,2,2,3]` → 返回 `5`，数组前 5 个元素为 `[1,1,2,2,3]`

### 核心思想
使用**快慢指针 + 计数器**。维护当前数字 `current` 和它的出现次数 `count`。当次数 < 2 时允许移动元素，否则跳过。

### 关键点
1. **快慢指针 + 计数**：
   - `slow`：下一个元素应该放置的位置
   - `fast`：遍历数组的指针
   - `current`：当前正在处理的数字
   - `count`：当前数字已经出现的次数
2. **处理逻辑**：
   - 如果 `nums[fast] == current`：
     - 如果 `count < 2`：移动，`count++`
     - 否则：跳过
   - 如果 `nums[fast] != current`：新数字，重置 `current` 和 `count`

### 复杂度分析
- **时间复杂度**：$O(n)$，单次遍历
- **空间复杂度**：$O(1)$，原地操作

```java
class Solution {
    public int removeDuplicates(int[] nums) {
        int fast = 0;      // 遍历指针
        int slow = 0;      // 下一个元素的位置
        int current = -1;  // 当前正在处理的数字
        int count = 0;     // 当前数字的出现次数
        
        while (fast < nums.length) {
            if (nums[fast] == current) {
                // 相同数字
                if (count < 2) {
                    // 还未达到 2 次，允许移动
                    count++;
                    nums[slow++] = nums[fast++];
                } else {
                    // 已经 2 次了，跳过
                    fast++;
                }
            } else {
                // 新数字，重置计数器
                current = nums[fast];
                nums[slow++] = nums[fast++];
                count = 1;
            }
        }
        return slow;
    }
}
```

# 977. [Squares of a Sorted Array](https://leetcode.com/problems/squares-of-a-sorted-array/description/)

### 题目描述
给定一个按非递减顺序排列的整数数组 `nums`，返回每个数字的平方组成的新数组，要求也按非递减顺序排列。

例如：`[-4,-1,0,3,10]` → `[0,1,9,16,100]`

### 核心思想
由于数组可能包含负数，平方后最大的数可能在两端。使用**双指针**从两端向中间移动，比较绝对值的大小，从后向前填充结果数组。

### 关键点
1. **双指针**：`left` 从 0 开始，`right` 从末尾开始
2. **比较绝对值**：`|nums[left]|` vs `|nums[right]|`
3. **从后向前填充**：结果数组从最大值开始填充
4. **移动指针**：选择绝对值较大的那一边

### 复杂度分析
- **时间复杂度**：$O(n)$，单次遍历
- **空间复杂度**：$O(n)$，结果数组空间

```java
class Solution {
    public int[] sortedSquares(int[] nums) {
        int[] result = new int[nums.length];
        int left = 0;
        int right = nums.length - 1;
        int index = nums.length - 1;  // 从后向前填充结果
        
        while (left <= right) {
            // 比较两端的绝对值
            if (Math.abs(nums[left]) > nums[right]) {
                // 左边绝对值更大
                result[index] = nums[left] * nums[left];
                left++;
            } else {
                // 右边绝对值更大或相等
                result[index] = nums[right] * nums[right];
                right--;
            }
            index--;
        }
        return result;
    }
}
```
