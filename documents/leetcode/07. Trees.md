# Trees

## Basic DFS/BFS

### 104. [Maximum Depth](https://leetcode.com/problems/maximum-depth-of-binary-tree/)
```java
class Solution {
    public int maxDepth(TreeNode node) {
        if (node == null) return 0;
        return Math.max(maxDepth(node.right), maxDepth(node.left)) + 1;
    }
}
```

### 100. [Same Tree](https://leetcode.com/problems/same-tree/)
```java
class Solution {
    public boolean isSameTree(TreeNode p, TreeNode q) {
        if (p == null && q == null) {
            return true;
        }
        if (p == null || q == null) {
            return false;
        }
        return p.val == q.val && this.isSameTree(p.left, q.left) && this.isSameTree(p.right, q.right);
    }
}
```

### 101. [Symmetric Tree](https://leetcode.com/problems/symmetric-tree/)
```java
class Solution {
    public boolean isSymmetric(TreeNode root) {
        return root == null || this.helper(root.left, root.right);
    }

    private boolean helper(TreeNode left, TreeNode right) {
        if (left == null && right == null) {
            return true;
        }
        if (left == null || right == null) {
            return false;
        }
        return left.val == right.val && this.helper(left.left, right.right) && this.helper(left.right, right.left);
    }
}
```

### 226. [Invert Binary Tree](https://leetcode.com/problems/invert-binary-tree/)
```java
class Solution {
    public TreeNode invertTree(TreeNode node) {
        if (node == null) {
            return null;
        }
        TreeNode right = node.right;
        TreeNode left = node.left;
        node.left = this.invertTree(right);
        node.right = this.invertTree(left);
        return node;
    }
}
```

### 112. [Path Sum](https://leetcode.com/problems/path-sum/)
```java
class Solution {
    public boolean hasPathSum(TreeNode root, int targetSum) {
        if (root == null) {
            return false;
        }
        if (root.left == null && root.right == null) {
            return root.val == targetSum;
        }
        int remainTarget = targetSum - root.val;
        boolean leftMatch = this.hasPathSum(root.left, remainTarget);
        boolean rightMatch = this.hasPathSum(root.right, remainTarget);
        return leftMatch || rightMatch;
    }
}
```

### 113. [Path Sum II](https://leetcode.com/problems/path-sum-ii/)
```java
import java.util.ArrayList;
import java.util.LinkedList;
import java.util.List;

class Solution {
    List<List<Integer>> result;

    public List<List<Integer>> pathSum(TreeNode root, int targetSum) {
        result = new ArrayList<>();
        LinkedList<Integer> pathList = new LinkedList<>();
        this.helper(root, targetSum, pathList);
        return result;
    }

    private void helper(TreeNode node, int targetSum, LinkedList<Integer> pathList) {
        if (node == null) {
            return;
        }
        pathList.addLast(node.val);
        if (node.left == null && node.right == null && targetSum == node.val) {
            result.add(new ArrayList<>(pathList));
        }
        this.helper(node.left, targetSum - node.val, pathList);
        this.helper(node.right, targetSum - node.val, pathList);
        pathList.removeLast();
    }
}
```

### 437. [Path Sum III](https://leetcode.com/problems/path-sum-iii/)
```java
class Solution {
    public int pathSum(TreeNode node, long targetSum) {
        if (node == null) {
            return 0;
        }
        int result = 0;
        // 计算以 node 为起点的路径满足条件的路径的数量
        result = result + this.helper(node, targetSum);

        // 通过递归计算 node 下面的子节点满足条件的路径的数量，并求和
        result = result + this.pathSum(node.left, targetSum);
        result = result + this.pathSum(node.right, targetSum);
        return result;
    }

    /**
     * 计算以 node 为起点，能有多少条路径的和与target相等
     *
     * @param node 起点
     * @param target 目标
     * @return 路径的数量
     */
    private int helper(TreeNode node, long target) {
        int result = 0;
        if (node == null) {
            return result;
        }
        long delta = target - node.val;
        if (delta == 0) {
            result++;
        }
        return this.helper(node.left, delta) + this.helper(node.right, delta) + result;
    }
}
```

```java
import java.util.HashMap;
import java.util.Map;

class Solution {
    public int pathSum(TreeNode node, long targetSum) {
        if (node == null) {
            return 0;
        }
        Map<Long, Integer> map = new HashMap<Long, Integer>();
        map.put(0L, 1);
        return this.helper(node, 0, targetSum, map);
    }

    // count the qualified paths that start from a node and go to anywhere.
    private int helper(TreeNode node, long curSum, long targetSum, Map<Long, Integer> map) {
        if (node == null) {
            return 0;
        }

        curSum += node.val;
        // 在更新map之前，查询符合条件的路径数
        int result = map.getOrDefault(curSum - targetSum, 0);

        // 再更新 map 状态
        int prevCount = map.getOrDefault(curSum, 0);
        map.put(curSum, prevCount + 1);

        result += this.helper(node.left, curSum, targetSum, map);
        result += this.helper(node.right, curSum, targetSum, map);

        // dfs 恢复状态
        map.put(curSum, prevCount);
        return result;
    }
}
```

### 257. [Binary Tree Paths](https://leetcode.com/problems/binary-tree-paths/)
```java
import java.util.ArrayList;
import java.util.LinkedList;
import java.util.List;

class Solution {

    List<String> result;

    public List<String> binaryTreePaths(TreeNode root) {
        LinkedList<Integer> list = new LinkedList<Integer>();
        result = new ArrayList<>();
        this.helper(root, list);
        return result;
    }

    private void helper(TreeNode node, LinkedList<Integer> list) {
        if (node == null)
            return;

        list.addLast(node.val);
        if (node.left == null && node.right == null) {
            StringBuilder path = new StringBuilder();
            for (int i = 0; i < list.size(); i++) {
                path.append(list.get(i));
                if (i < list.size() - 1) {
                    path.append("->");
                }
            }
            result.add(path.toString());
        }

        this.helper(node.left, list);
        this.helper(node.right, list);

        list.removeLast();
    }
}
```

### 129. [Sum Root to Leaf Numbers](https://leetcode.com/problems/sum-root-to-leaf-numbers/)
```java
class Solution {
    public int sumNumbers(TreeNode root) {
        return this.helper(root, 0);
    }

    public int helper(TreeNode node, int num) {
        if (node == null) {
            return 0;
        }
        // 计算到叶子结点停止
        int newNum = num * 10 + node.val;
        if (node.left == null && node.right == null) {
            return newNum;
        }
        return this.helper(node.left, newNum) + this.helper(node.right, newNum);
    }
}
```

## Traversal

### 94. [Inorder](https://leetcode.com/problems/binary-tree-inorder-traversal/)
```java
import java.util.ArrayList;
import java.util.List;
import java.util.Stack;

class Solution {
    public List<Integer> inorderTraversal(TreeNode root) {
        List<Integer> list = new ArrayList<>();
        Stack<TreeNode> stack = new Stack<>();
        TreeNode iter = root;
        while (iter != null || !stack.isEmpty()) {
            while (iter != null) {
                stack.push(iter);
                iter = iter.left;
            }
            iter = stack.pop();
            list.add(iter.val);
            iter = iter.right;
        }

        return list;
    }
}
```

### 144. [Preorder](https://leetcode.com/problems/binary-tree-preorder-traversal/)
```java

```

### 145. [Postorder](https://leetcode.com/problems/binary-tree-postorder-traversal/)
```java

```

### 102. [Level Order](https://leetcode.com/problems/binary-tree-level-order-traversal/)
```java

```

### 103. [Zigzag Level Order](https://leetcode.com/problems/binary-tree-zigzag-level-order-traversal/)
```java

```

## BST

### 98. [Validate BST](https://leetcode.com/problems/validate-binary-search-tree/)
```java

```

### 701. [Insert into BST](https://leetcode.com/problems/insert-into-a-binary-search-tree/)
```java

```

### 450. [Delete Node in BST](https://leetcode.com/problems/delete-node-in-a-bst/)
```java

```

### 230. [Kth Smallest in BST](https://leetcode.com/problems/kth-smallest-element-in-a-bst/)
```java

```

### 235. [LCA of BST](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-search-tree/)
```java

```

### 236. [LCA of BT](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/)
```java

```

## Tree DP & Hard

### 124. [Binary Tree Maximum Path Sum](https://leetcode.com/problems/binary-tree-maximum-path-sum/)
```java

```

### 110. [Balanced Binary Tree](https://leetcode.com/problems/balanced-binary-tree/)
```java

```

### 105. [Construct Tree from Preorder + Inorder](https://leetcode.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/)
```java

```

### 106. [Construct Tree from Inorder + Postorder](https://leetcode.com/problems/construct-binary-tree-from-inorder-and-postorder-traversal/)
```java

```

### 108. [Convert Sorted Array to BST](https://leetcode.com/problems/convert-sorted-array-to-binary-search-tree/)
```java

```

### 208. [Trie (actually Trie category)](https://leetcode.com/problems/implement-trie-prefix-tree/)
```java

```

### 211. [Add & Search Word](https://leetcode.com/problems/design-add-and-search-words-data-structure/)
```java

```

### 212. [Word Search II](https://leetcode.com/problems/word-search-ii/)
```java

```
