# Trees

## Basic DFS/BFS

### 104. [Maximum Depth](https://leetcode.com/problems/maximum-depth-of-binary-tree/)
```java
class Solution {
    public int maxDepth(TreeNode node) {
        if (node == null) return 0;
        return Math.max(maxDepth(node.right), maxDepth(node.left)) + 1;
    }
}
```

### 100. [Same Tree](https://leetcode.com/problems/same-tree/)
```java
class Solution {
    public boolean isSameTree(TreeNode p, TreeNode q) {
        if (p == null && q == null) {
            return true;
        }
        if (p == null || q == null) {
            return false;
        }
        return p.val == q.val && this.isSameTree(p.left, q.left) && this.isSameTree(p.right, q.right);
    }
}
```

### 101. [Symmetric Tree](https://leetcode.com/problems/symmetric-tree/)
```java
class Solution {
    public boolean isSymmetric(TreeNode root) {
        return root == null || this.helper(root.left, root.right);
    }

    private boolean helper(TreeNode left, TreeNode right) {
        if (left == null && right == null) {
            return true;
        }
        if (left == null || right == null) {
            return false;
        }
        return left.val == right.val && this.helper(left.left, right.right) && this.helper(left.right, right.left);
    }
}
```

### 226. [Invert Binary Tree](https://leetcode.com/problems/invert-binary-tree/)
```java
class Solution {
    public TreeNode invertTree(TreeNode node) {
        if (node == null) {
            return null;
        }
        TreeNode right = node.right;
        TreeNode left = node.left;
        node.left = this.invertTree(right);
        node.right = this.invertTree(left);
        return node;
    }
}
```

### 112. [Path Sum](https://leetcode.com/problems/path-sum/)
```java
class Solution {
    public boolean hasPathSum(TreeNode root, int targetSum) {
        if (root == null) {
            return false;
        }
        if (root.left == null && root.right == null) {
            return root.val == targetSum;
        }
        int remainTarget = targetSum - root.val;
        boolean leftMatch = this.hasPathSum(root.left, remainTarget);
        boolean rightMatch = this.hasPathSum(root.right, remainTarget);
        return leftMatch || rightMatch;
    }
}
```

### 113. [Path Sum II](https://leetcode.com/problems/path-sum-ii/)
```java
import java.util.ArrayList;
import java.util.LinkedList;
import java.util.List;

class Solution {
    List<List<Integer>> result;

    public List<List<Integer>> pathSum(TreeNode root, int targetSum) {
        result = new ArrayList<>();
        LinkedList<Integer> pathList = new LinkedList<>();
        this.helper(root, targetSum, pathList);
        return result;
    }

    private void helper(TreeNode node, int targetSum, LinkedList<Integer> pathList) {
        if (node == null) {
            return;
        }
        pathList.addLast(node.val);
        if (node.left == null && node.right == null && targetSum == node.val) {
            result.add(new ArrayList<>(pathList));
        }
        this.helper(node.left, targetSum - node.val, pathList);
        this.helper(node.right, targetSum - node.val, pathList);
        pathList.removeLast();
    }
}
```

### 437. [Path Sum III](https://leetcode.com/problems/path-sum-iii/)
```java
class Solution {
    public int pathSum(TreeNode node, long targetSum) {
        if (node == null) {
            return 0;
        }
        int result = 0;
        // 计算以 node 为起点的路径满足条件的路径的数量
        result = result + this.helper(node, targetSum);

        // 通过递归计算 node 下面的子节点满足条件的路径的数量，并求和
        result = result + this.pathSum(node.left, targetSum);
        result = result + this.pathSum(node.right, targetSum);
        return result;
    }

    /**
     * 计算以 node 为起点，能有多少条路径的和与target相等
     *
     * @param node 起点
     * @param target 目标
     * @return 路径的数量
     */
    private int helper(TreeNode node, long target) {
        int result = 0;
        if (node == null) {
            return result;
        }
        long delta = target - node.val;
        if (delta == 0) {
            result++;
        }
        return this.helper(node.left, delta) + this.helper(node.right, delta) + result;
    }
}
```

```java
import java.util.HashMap;
import java.util.Map;

class Solution {
    public int pathSum(TreeNode node, long targetSum) {
        if (node == null) {
            return 0;
        }
        Map<Long, Integer> map = new HashMap<Long, Integer>();
        map.put(0L, 1);
        return this.helper(node, 0, targetSum, map);
    }

    // count the qualified paths that start from a node and go to anywhere.
    private int helper(TreeNode node, long curSum, long targetSum, Map<Long, Integer> map) {
        if (node == null) {
            return 0;
        }

        curSum += node.val;
        // 在更新map之前，查询符合条件的路径数
        int result = map.getOrDefault(curSum - targetSum, 0);

        // 再更新 map 状态
        int prevCount = map.getOrDefault(curSum, 0);
        map.put(curSum, prevCount + 1);

        result += this.helper(node.left, curSum, targetSum, map);
        result += this.helper(node.right, curSum, targetSum, map);

        // dfs 恢复状态
        map.put(curSum, prevCount);
        return result;
    }
}
```

### 257. [Binary Tree Paths](https://leetcode.com/problems/binary-tree-paths/)
```java
import java.util.ArrayList;
import java.util.LinkedList;
import java.util.List;

class Solution {

    List<String> result;

    public List<String> binaryTreePaths(TreeNode root) {
        LinkedList<Integer> list = new LinkedList<Integer>();
        result = new ArrayList<>();
        this.helper(root, list);
        return result;
    }

    private void helper(TreeNode node, LinkedList<Integer> list) {
        if (node == null)
            return;

        list.addLast(node.val);
        if (node.left == null && node.right == null) {
            StringBuilder path = new StringBuilder();
            for (int i = 0; i < list.size(); i++) {
                path.append(list.get(i));
                if (i < list.size() - 1) {
                    path.append("->");
                }
            }
            result.add(path.toString());
        }

        this.helper(node.left, list);
        this.helper(node.right, list);

        list.removeLast();
    }
}
```

### 129. [Sum Root to Leaf Numbers](https://leetcode.com/problems/sum-root-to-leaf-numbers/)
```java
class Solution {
    public int sumNumbers(TreeNode root) {
        return this.helper(root, 0);
    }

    public int helper(TreeNode node, int num) {
        if (node == null) {
            return 0;
        }
        // 计算到叶子结点停止
        int newNum = num * 10 + node.val;
        if (node.left == null && node.right == null) {
            return newNum;
        }
        return this.helper(node.left, newNum) + this.helper(node.right, newNum);
    }
}
```

## Traversal

### 94. [Inorder](https://leetcode.com/problems/binary-tree-inorder-traversal/)
```java
import java.util.ArrayList;
import java.util.List;
import java.util.Stack;

class Solution {
    public List<Integer> inorderTraversal(TreeNode root) {
        List<Integer> list = new ArrayList<>();
        Stack<TreeNode> stack = new Stack<>();
        TreeNode iter = root;
        while (iter != null || !stack.isEmpty()) {
            while (iter != null) {
                stack.push(iter);
                iter = iter.left;
            }
            iter = stack.pop();
            list.add(iter.val);
            iter = iter.right;
        }

        return list;
    }
}
```

### 144. [Preorder](https://leetcode.com/problems/binary-tree-preorder-traversal/)
```java
import java.util.ArrayList;
import java.util.List;

class Solution {
    public List<Integer> preorderTraversal(TreeNode root) {
        List<Integer> result = new ArrayList<Integer>();
        preorder(root, result);
        return result;
    }

    public void preorder(TreeNode root, List<Integer> result) {
        if (root == null)
            return;
        result.add(root.val);
        preorder(root.left, result);
        preorder(root.right, result);

    }
}

```

### 145. [Postorder](https://leetcode.com/problems/binary-tree-postorder-traversal/)
```java
import java.util.ArrayList;
import java.util.List;

class Solution {
    static List<Integer> ans;

    public static void preorder(TreeNode root) {
        if (root == null)
            return;
        preorder(root.left);
        preorder(root.right);
        ans.add(root.val);
    }

    public List<Integer> postorderTraversal(TreeNode root) {
        ans = new ArrayList<>();
        preorder(root);
        return ans;
    }
}
```

### 102. [Level Order](https://leetcode.com/problems/binary-tree-level-order-traversal/)
```java
class Solution {
    private List<List<Integer>> result = new ArrayList<>();

    public List<List<Integer>> levelOrder(TreeNode root) {
        this.helper(root);
        return result;
    }

    public void helper(TreeNode root) {
        if (root == null) return;
        List<TreeNode> level = new ArrayList<>();
        level.add(root);
        result.add(Collections.singletonList(root.val));
        while (!level.isEmpty()) {
            List<TreeNode> nextLevel = new ArrayList<>();
            for (TreeNode treeNode : level) {
                if (treeNode.left != null) nextLevel.add(treeNode.left);
                if (treeNode.right != null) nextLevel.add(treeNode.right);
            }
            if (nextLevel.isEmpty()) return;
            List<Integer> list = new ArrayList<>();
            for (TreeNode node : nextLevel) list.add(node.val);
            result.add(list);
            level.clear();
            level.addAll(nextLevel);
        }
    }
}
```

### 103. [Zigzag Level Order](https://leetcode.com/problems/binary-tree-zigzag-level-order-traversal/)
```java
class Solution {

    public List<List<Integer>> zigzagLevelOrder(TreeNode root) {
        List<List<Integer>> res = new ArrayList<>();
        LinkedList<TreeNode> levelList = new LinkedList<>();

        levelList.addLast(root);

        boolean flag = false;
        while (levelList.size() != 0) {
            LinkedList<Integer> curLevelList = new LinkedList<>();
            LinkedList<TreeNode> tempLevelList = new LinkedList<>();

            while (levelList.size() != 0) {
                TreeNode node = flag ? levelList.pollLast() : levelList.pollFirst();
                if (node != null) {
                    curLevelList.add(node.val);
                    if (flag) {
                        tempLevelList.addFirst(node.right);
                        tempLevelList.addFirst(node.left);
                    } else {
                        tempLevelList.addLast(node.left);
                        tempLevelList.addLast(node.right);
                    }
                }
            }
            levelList = tempLevelList;
            if (curLevelList.size() != 0) res.add(curLevelList);

            flag = !flag;
        }
        return res;
    }
}
```

## Others

### 236. [Lowest Common Ancestor of a Binary Tree](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/description/)

```java
class Solution {
    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {
        // 如果目标节点就是节点本身，那么直接返回
        if (root == null || p == root || q == root) {
            return root;
        }
        // 在以 left or right 的子树中分别寻找 p 或者 q
        TreeNode left = this.lowestCommonAncestor(root.left, p, q);
        TreeNode right = this.lowestCommonAncestor(root.right, p, q);
        // 如果两边都不为空，那么说明 p 和 q 分别位于两边
        if (left != null && right != null) {
            return root;
        }
        // 如果某一侧为空，那么说明 p 和 q 位于同一侧
        return left == null ? right : left;
    }
}
```

这是一个**二叉树（不是二叉搜索树）中求最近公共祖先（Lowest Common Ancestor, LCA）**的经典递归写法。

#### 1、这段代码的核心思想

一句话总结：

> 用后序遍历，从底往上找，只要左右子树各找到一个目标节点，那么当前节点就是最近公共祖先。

---

#### 2、递归函数的真正含义

```java
public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q)
```

这个函数的语义是：

> 在以 root 为根的子树中查找 p 和 q，
> 返回值代表：
>
> * 如果当前子树里 **没有 p 或 q** → 返回 null
> * 如果只找到一个（p 或 q） → 返回找到的那个节点
> * 如果左右子树分别找到了 p 和 q → 返回当前 root（LCA）

---

#### 3、第一步：递归终止条件

```java
if (root == null || root == p || root == q) return root;
```

什么意思？

##### 情况 1：root == null

树到底了，没找到 → 返回 null

##### 情况 2：root == p

找到了 p → 直接返回 p

##### 情况 3：root == q

找到了 q → 直接返回 q

这一步非常关键：

它相当于告诉父节点：

> “我这里找到了目标节点”

---

#### 4、递归左右子树

```java
TreeNode left = this.lowestCommonAncestor(root.left, p, q);
TreeNode right = this.lowestCommonAncestor(root.right, p, q);
```

这一步是后序遍历：

* 先查左子树
* 再查右子树
* 最后处理中间节点

---

#### 5、关键判断逻辑

```java
if (left != null && right != null) return root;
```

这行是灵魂。

如果：

* 左子树找到了一个目标
* 右子树找到了另一个目标

那说明：

> p 和 q 分别在当前 root 的两边
> 当前 root 就是最近公共祖先

为什么是“最近”？

因为递归是从底往上返回的，
第一个满足左右都有结果的节点一定是最低的那个。

---

#### 6、最后一行的意义

```java
return left == null ? right : left;
```

意思是：

* 如果左子树没找到 → 返回右子树的结果
* 如果右子树没找到 → 返回左子树的结果

也就是说：

> 把找到的那个节点往上传递

---

#### 7、时间和空间复杂度

时间复杂度：

```
O(n)
```

每个节点访问一次。

空间复杂度：

```
O(h)
```

递归栈深度，最坏退化为链表是 O(n)。

### [513. Find Bottom Left Tree Value](https://leetcode.com/problems/find-bottom-left-tree-value/description/)

```java
class Solution {

    int max = 0;
    int res = 0;

    public int findBottomLeftValue(TreeNode root) {
        helper(root, 1);
        return res;
    }

    public void helper(TreeNode node, int level) {
        if (node == null) {
            return;
        }
        if (level > max) {
            res = node.val;
            max = level;
        }
        this.helper(node.left, level + 1);
        this.helper(node.right, level + 1);
    }
}

```

### [404. Sum of Left Leaves](https://leetcode.com/problems/sum-of-left-leaves/)
```java
class Solution {
    int result = 0;

    public int sumOfLeftLeaves(TreeNode root) {
        this.helper(root, false);
        return result;
    }

    private void helper(TreeNode node, boolean isLeft) {
        if (node == null) {
            return;
        }
        if (node.left == null && node.right == null) {
            if (isLeft) {
                result += node.val;
            }
            return;
        }
        this.helper(node.left, true);
        this.helper(node.right, false);
    }
}
```