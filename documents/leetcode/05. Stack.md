# Stack / Monotonic Stack

## 20. [Valid Parentheses](https://leetcode.com/problems/valid-parentheses/)

### 题目描述
给定一个只包含 `'('`, `')'`, `'{'`, `'}'`, `'['`, `']'` 的字符串，判断字符串是否有效。有效字符串需满足：
1. 左括号必须用相同类型的右括号闭合
2. 左括号必须以正确的顺序闭合

例如：`"()"`, `"()[]{}"`, `"{[]}"` 是有效的，`"(]"`, `"([)]"` 是无效的。

### 核心思想
使用**栈来匹配括号**。遇到左括号压栈，遇到右括号检查是否与栈顶匹配。利用 ASCII 码差值判断括号配对。

### 关键点
1. **左括号** `'('`, `'['`, `'{'`：直接压栈
2. **右括号**：检查栈顶是否为对应的左括号
3. **ASCII 码技巧**：配对的括号 ASCII 码差值不超过 2
   - `')'` - `'('` = 1
   - `']'` - `'['` = 2
   - `'}'` - `'{'` = 2
4. **最终检查**：栈必须为空（所有左括号都被匹配）

### 执行过程示例
对于字符串 `"{[()]}"` 的执行过程：

```
字符  栈的变化       说明
初始  []            
{     ['{']         左括号，压栈
[     ['{', '[']    左括号，压栈
(     ['{', '[', '(']  左括号，压栈
)     ['{', '[']    ')' 与 '(' 匹配（差值=1），弹出
]     ['{']         ']' 与 '[' 匹配（差值=2），弹出
}     []            '}' 与 '{' 匹配（差值=2），弹出
结果  栈空，返回 true
```

### 复杂度分析
- **时间复杂度**：$O(n)$，遍历字符串一次
- **空间复杂度**：$O(n)$，最坏情况下全是左括号

```java
class Solution {
    public boolean isValid(String s) {
        char[] chars = s.toCharArray();
        LinkedList<Character> linkedList = new LinkedList<>();
        for (char c : chars) {
            if (c == '{' || c == '[' || c == '(') {
                linkedList.push(c);  // 左括号压栈
            } else {
                Character peek = linkedList.peek();
                // 栈空 或 ASCII码差值>2（不匹配）
                if (peek == null || Math.abs(c - peek) > 2) return false;
                else linkedList.pop();  // 匹配成功，弹出
            }
        }
        return linkedList.isEmpty();  // 检查是否所有括号都匹配
    }
}
```

## 155. [Min Stack](https://leetcode.com/problems/min-stack/)

### 题目描述
设计一个支持 push、pop、top 操作的栈，并能在常数时间内检索到最小元素。

实现 MinStack 类：
- `push(x)` - 将元素 x 推入栈中
- `pop()` - 删除栈顶的元素
- `top()` - 获取栈顶元素
- `getMin()` - 检索栈中的最小元素（O(1) 时间复杂度）

### 核心思想
使用**双栈同步维护**：
- `stack`：存储正常数据
- `minStack`：每个位置存储**截止到该位置的最小值**

两个栈同步 push/pop，`minStack` 的栈顶始终是当前栈的最小值。

### 关键点
1. **初始化**：`minStack` 预先压入 `Integer.MAX_VALUE`，避免首次 push 时的空指针
2. **push 操作**：
   - `stack` 压入新值 x
   - `minStack` 压入 `min(x, minStack.peek())`，保存当前最小值
3. **pop 操作**：两个栈同步弹出
4. **getMin 操作**：返回 `minStack.peek()`，O(1) 时间

### 执行过程示例
操作序列：`push(-2)`, `push(0)`, `push(-3)`, `getMin()`, `pop()`, `top()`, `getMin()`

```
操作          stack          minStack       说明
初始化        []             [MAX_VALUE]    
push(-2)     [-2]           [MAX_VALUE, -2]   min(-2, MAX)=-2
push(0)      [-2, 0]        [MAX_VALUE, -2, -2]  min(0, -2)=-2
push(-3)     [-2, 0, -3]    [MAX_VALUE, -2, -2, -3]  min(-3, -2)=-3
getMin()     -              -              返回 -3
pop()        [-2, 0]        [MAX_VALUE, -2, -2]  同步弹出
top()        -              -              返回 0
getMin()     -              -              返回 -2
```

### 复杂度分析
- **时间复杂度**：所有操作均为 $O(1)$
- **空间复杂度**：$O(n)$，需要额外的 minStack

```java
class MinStack {

    // 存储正常的栈
    private LinkedList<Integer> stack;
    // 存储截止到当前位置最小的数字
    private LinkedList<Integer> minStack;
    
    public MinStack() {
        stack = new LinkedList<>();
        minStack = new LinkedList<>();
        minStack.push(Integer.MAX_VALUE);  // 初始化，避免空指针
    }

    public void push(int x) {
        stack.push(x);
        // 压入当前最小值
        minStack.push(Math.min(x, minStack.peek()));
    }

    public void pop() {
        stack.pop();
        minStack.pop();  // 同步弹出
    }

    public int top() {
        return stack.peek();
    }

    public int getMin() {
        return minStack.peek();  // O(1) 获取最小值
    }
}
```

## 150. [Evaluate Reverse Polish Notation](https://leetcode.com/problems/evaluate-reverse-polish-notation/)

### 题目描述
根据逆波兰表示法（后缀表达式），求表达式的值。

有效的运算符包括 `+`, `-`, `*`, `/`。每个运算对象可以是整数或另一个逆波兰表达式。

例如：
- `["2","1","+","3","*"]` → `((2 + 1) * 3) = 9`
- `["4","13","5","/","+"]` → `(4 + (13 / 5)) = 6`

### 核心思想
使用**栈处理后缀表达式**：
- 遇到**数字**：压栈
- 遇到**运算符**：弹出两个数字进行运算，结果压回栈
- 最终栈中只剩一个元素，即为结果

### 关键点
1. **数字入栈**：将数字字符串压入栈中
2. **运算符处理**：
   - `num1 = stack.pop()`：第二个操作数（后弹出）
   - `num2 = stack.pop()`：第一个操作数（先弹出）
   - **注意顺序**：对于 `-` 和 `/`，顺序很重要（`num2 op num1`）
3. **结果入栈**：运算结果转为字符串压回栈

### 执行过程示例
对于 `["2","1","+","3","*"]` 的执行过程：

```
token  栈的变化       操作
"2"    ["2"]         数字入栈
"1"    ["2", "1"]    数字入栈
"+"    ["3"]         弹出1和2，计算2+1=3，入栈
"3"    ["3", "3"]    数字入栈
"*"    ["9"]         弹出3和3，计算3*3=9，入栈
结果   9
```

### 复杂度分析
- **时间复杂度**：$O(n)$，遍历 tokens 数组一次
- **空间复杂度**：$O(n)$，栈的空间

```java
import java.util.LinkedList;

class Solution {

    public int evalRPN(String[] tokens) {

        LinkedList<String> stack = new LinkedList<>();

        for (String token : tokens) {
            // 如果是数字，直接入栈
            if (!token.equals("+") && !token.equals("-") && !token.equals("*") && !token.equals("/")) {
                stack.push(token);
                continue;
            }
            // 遇到运算符，弹出两个数字
            int num1 = Integer.parseInt(stack.pop());  // 第二个操作数
            int num2 = Integer.parseInt(stack.pop());  // 第一个操作数
            int res = 0;
            switch (token) {
                case "+":
                    res = num1 + num2;
                    break;
                case "-":
                    res = num2 - num1;  // 注意顺序
                    break;
                case "*":
                    res = num1 * num2;
                    break;
                case "/":
                    res = num2 / num1;  // 注意顺序
                    break;
            }
            stack.push(String.valueOf(res));  // 结果入栈
        }
        return Integer.parseInt(stack.pop());  // 最终结果
    }
}
```

## 394. [Decode String](https://leetcode.com/problems/decode-string/)

### 题目描述
给定一个经过编码的字符串，返回它解码后的字符串。编码规则为：`k[encoded_string]`，表示其中方括号内的 `encoded_string` 正好重复 k 次。

例如：
- `"3[a]2[bc]"` → `"aaabcbc"`
- `"3[a2[c]]"` → `"accaccacc"`
- `"2[abc]3[cd]ef"` → `"abcabccdcdcdef"`

### 核心思想
使用**栈处理嵌套结构**：
- 遇到数字、字母、`'['`：压栈
- 遇到 `']'`：
  1. 弹出栈顶字符直到遇到 `'['`，得到待重复的字符串
  2. 继续弹出数字，得到重复次数
  3. 生成重复后的字符串，逐字符压回栈

### 关键点
1. **遇到 `']'` 的处理流程**：
   - 收集 `'['` 之前的字符串（base）
   - 收集 `'['` 之前的数字（重复次数）
   - 生成重复字符串并压回栈
2. **数字可能是多位**：需要用 StringBuilder 逐位收集
3. **嵌套处理**：内层解码完成后，字符逐个压栈，可能成为外层的一部分

### 执行过程示例
对于字符串 `"3[a2[c]]"` 的执行过程：

```
字符  栈的变化                操作
'3'   ['3']                  数字入栈
'['   ['3', '[']             '[' 入栈
'a'   ['3', '[', 'a']         字母入栈
'2'   ['3', '[', 'a', '2']    数字入栈
'['   ['3', '[', 'a', '2', '[']  '[' 入栈
'c'   ['3', '[', 'a', '2', '[', 'c']  字母入栈
']'   ['3', '[', 'a', 'c', 'c']  处理2[c]：弹出'c'，重复2次="cc"，逐字符压栈
']'   ['a', 'c', 'c', 'a', 'c', 'c', 'a', 'c', 'c']  处理3[acc]：弹出"acc"，重复3次
结果  "accaccacc"
```

### 复杂度分析
- **时间复杂度**：$O(n \times k)$，n 是解码后字符串长度，k 是最大重复次数
- **空间复杂度**：$O(n)$，栈的空间

```java
class Solution {
    public String decodeString(String s) {
        Stack<Character> stack = new Stack<>();
        char[] chars = s.toCharArray();
        for (int i = 0; i < chars.length; i++) {
            char c = chars[i];
            // 数字、字母、'[' 都直接入栈
            if ((c >= '0' && c <= '9') || (c >= 'a' && c <= 'z') || c == '[') {
                stack.push(c);
            } else if (c == ']') {
                // 收集 '[' 内的字符串
                StringBuilder base = new StringBuilder();
                while (stack.peek() != '[') {
                    base.insert(0, stack.pop());
                }
                stack.pop();  // 弹出 '['
                
                // 收集重复次数（可能是多位数字）
                StringBuilder numc = new StringBuilder();
                while (!stack.empty() && (stack.peek() >= '0' && stack.peek() <= '9')) {
                    numc.insert(0, stack.pop());
                }
                
                // 生成重复字符串并逐字符压回栈
                String repeated = repeat(Integer.parseInt(numc.toString()), base.toString());
                for (char c1 : repeated.toCharArray()) {
                    stack.push(c1);
                }
            }
        }
        // 构建最终结果
        String result = "";
        while (!stack.empty()) {
            result = stack.pop() + result;
        }
        return result;
    }

    // 辅助方法：重复字符串 n 次
    public String repeat(int n, String base) {
        StringBuilder result = new StringBuilder();
        for (int j = 0; j < n; j++) {
            result.append(base);
        }
        return result.toString();
    }

}
```

## 739. [Daily Temperatures](https://leetcode.com/problems/daily-temperatures/)

### 题目描述
给定一个整数数组 `temperatures` 表示每天的温度，返回一个数组 `answer`，其中 `answer[i]` 是指对于第 `i` 天，下一个更高温度出现在几天后。如果之后都没有更高的温度，则 `answer[i] = 0`。

例如：`temperatures = [73,74,75,71,69,72,76,73]`
输出：`[1,1,4,2,1,1,0,0]`

### 核心思想
使用**单调递减栈**存储温度的索引。栈中索引对应的温度值从栈底到栈顶递减。当遇到更高温度时，弹出栈顶元素并计算天数差。

### 关键点
1. **栈存储索引**而非温度值，便于计算天数差
2. **单调性维护**：栈中索引对应的温度递减
3. **找到答案时机**：当前温度 > 栈顶索引的温度时，栈顶找到了答案
4. **未找到答案**：遍历结束后栈中剩余的索引，结果默认为 0

### 执行过程示例
对于 `temperatures = [73,74,75,71,69,72,76,73]` 的执行过程：

```
i  temp  栈的变化         操作
0  73    [0]             73入栈
1  74    [1]             74>73，弹出0，result[0]=1-0=1，74入栈
2  75    [2]             75>74，弹出1，result[1]=2-1=1，75入栈
3  71    [2, 3]          71<75，入栈
4  69    [2, 3, 4]       69<71，入栈
5  72    [2, 5]          72>69，弹出4，result[4]=5-4=1
                         72>71，弹出3，result[3]=5-3=2
                         72<75，入栈
6  76    [6]             76>72，弹出5，result[5]=6-5=1
                         76>75，弹出2，result[2]=6-2=4
                         76入栈
7  73    [6, 7]          73<76，入栈
结果  [1,1,4,2,1,1,0,0]   栈中剩余的6,7位置结果为0
```

### 复杂度分析
- **时间复杂度**：$O(n)$，每个元素最多入栈出栈各一次
- **空间复杂度**：$O(n)$，栈的空间

```java
class Solution {
    public int[] dailyTemperatures(int[] temperatures) {
        // 单调递减栈，存储索引
        Stack<Integer> stack = new Stack<>();
        int[] result = new int[temperatures.length];

        for (int i = 0; i < temperatures.length; i++) {
            // 当前温度比栈顶温度高，栈顶元素找到答案
            while (!stack.isEmpty() && temperatures[i] > temperatures[stack.peek()]) {
                int idx = stack.pop();
                result[idx] = i - idx;  // 计算天数差
            }
            stack.push(i);  // 当前索引入栈
        }

        return result;  // 栈中剩余的索引结果默认为0
    }
}
```

## 503. [Next Greater Element II](https://leetcode.com/problems/next-greater-element-ii/)

**题目**：给定一个循环数组（最后一个元素的下一个是第一个元素），找出每个元素的下一个更大元素。如果不存在，返回 -1。

**核心思想**：单调递减栈 + 循环数组处理

### 关键点：

1. **循环数组处理**：遍历两遍数组（`i < n * 2`），用 `i % n` 获取实际索引
2. **单调栈**：栈中存储数组下标，栈底到栈顶对应的元素值递减
3. **找到答案时机**：当前元素比栈顶元素大时，栈顶元素找到了答案

### 算法流程：

```
数组: [1, 2, 1]
遍历过程:
i=0: cur=1, 栈空, 入栈 → 栈:[0]
i=1: cur=2, 2>1, 弹出0, result[0]=2, 入栈 → 栈:[1]
i=2: cur=1, 1<2, 入栈 → 栈:[2,1]
i=3: cur=1 (循环), 1<2, 不入栈 → 栈:[2,1]
i=4: cur=2 (循环), 2>1, 弹出2,1, result[2]=2, result[1]=-1(不更新), 不入栈
结果: [2, -1, 2]
```

### 为什么遍历两遍？

- 第一遍：处理能在数组后面找到答案的元素
- 第二遍：处理需要循环到数组前面找答案的元素（如最后几个元素）
- 只在第一遍入栈（`if (i < n)`），避免重复处理

### 复杂度：
- 时间：O(n)，每个元素最多入栈出栈各一次
- 空间：O(n)，栈的空间

```java
import java.util.Arrays;
import java.util.LinkedList;

class Solution {
    public int[] nextGreaterElements(int[] nums) {
        int n = nums.length;
        int[] result = new int[n];
        Arrays.fill(result, -1);  // 初始化为-1（找不到答案的默认值）
        LinkedList<Integer> stack = new LinkedList<>();  // 单调栈，存储索引
        
        // 遍历两遍，模拟循环数组
        for (int i = 0; i < n * 2; i++) {
            if (stack.size() != 0) {
                int cur = nums[i % n];  // 当前元素值
                // 当前元素比栈顶元素大，栈顶元素找到答案
                while (stack.size() != 0 && cur > nums[stack.getFirst()]) {
                    int preIndex = stack.removeFirst();
                    result[preIndex] = cur;
                }
            }
            // 只在第一遍入栈，避免重复
            if (i < n) {
                stack.addFirst(i);
            }
        }

        return result;
    }
}
```

## 42. [Trapping Rain Water](https://leetcode.com/problems/trapping-rain-water/)

### 题目描述
给定 n 个非负整数表示每个宽度为 1 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。

例如：`heights = [0,1,0,2,1,0,1,3,2,1,2,1]`
输出：`6`（可以接 6 单位的雨水）

### 核心思想
**找到最高点，分别从左右两边向最高点扫描**：
- 左侧：维护左边最高墙，遇到更矮的位置就能接水
- 右侧：维护右边最高墙，遇到更矮的位置就能接水
- 最高点不会接水（它是最高的）

**关键洞察**：
- 某个位置能接的水量 = `min(左边最高, 右边最高) - 当前高度`
- 通过分段处理，每次只需考虑一侧的最高墙即可

### 关键点
1. **找到最高点**：作为分界点，避免重复计算
2. **从左向右扫描**（到最高点）：
   - 维护 `leftHeight`（当前遇到的最高墙）
   - 如果当前位置更矮，可以接 `leftHeight - curHeight` 的水
3. **从右向左扫描**（到最高点）：
   - 维护 `rightHeight`（当前遇到的最高墙）
   - 如果当前位置更矮，可以接 `rightHeight - curHeight` 的水

### 执行过程示例
对于 `heights = [0,1,0,2,1,0,1,3,2,1,2,1]` 的执行过程：

```
步骤1：找到最高点
最高点：index=7, height=3

步骤2：从左向右扫描（0 → 6）
i  height  leftHeight  接水量    说明
0    0        0         0        更新leftHeight=0
1    1        1         0        更新leftHeight=1
2    0        1         1        0<1，接1单位水
3    2        2         0        更新leftHeight=2
4    1        2         1        1<2，接1单位水
5    0        2         2        0<2，接2单位水
6    1        2         1        1<2，接1单位水
小计：5单位

步骤3：从右向左扫描（11 → 8）
i  height  rightHeight  接水量   说明
11   1        1         0        更新rightHeight=1
10   2        2         0        更新rightHeight=2
9    1        2         1        1<2，接1单位水
8    2        2         0        更新rightHeight=2
小计：1单位

总计：5+1=6单位
```

### 复杂度分析
- **时间复杂度**：$O(n)$，需要三次遍历（找最高点 + 左扫描 + 右扫描）
- **空间复杂度**：$O(1)$，只用常数额外空间

```java
class Solution {

    public int trap(int[] heights) {
        // 找到最高点
        int highestIndex = -1;
        int highest = -1;
        for (int i = 0; i < heights.length; i++) {
            if (highest < heights[i]) {
                highest = heights[i];
                highestIndex = i;
            }
        }
        
        // 从左向右扫描到最高点
        int leftHeight = 0;  // 左边最高墙
        int sumDeep = 0;
        for (int cur = 0; cur < highestIndex; cur++) {
            int curHeight = heights[cur];
            if (leftHeight <= curHeight) {
                leftHeight = curHeight;  // 更新左边最高墙
            } else {
                sumDeep = sumDeep + leftHeight - curHeight;  // 可以接水
            }
        }
        
        // 从右向左扫描到最高点
        int rightHeight = 0;  // 右边最高墙
        for (int cur = heights.length - 1; cur > highestIndex; cur--) {
            int curHeight = heights[cur];
            if (rightHeight <= curHeight) {
                rightHeight = curHeight;  // 更新右边最高墙
            } else {
                sumDeep = sumDeep + rightHeight - curHeight;  // 可以接水
            }
        }
        
        return sumDeep;
    }

}
```

## 32. [Longest Valid Parentheses](https://leetcode.com/problems/longest-valid-parentheses/)

**题目**：给定一个只包含 `'('` 和 `')'` 的字符串，找出最长的有效（格式正确且连续）括号子串的长度。

**核心思想**：一维动态规划

### 关键点：

1. **DP定义**：`dp[i]` 表示以 `s[i]` 结尾的最长有效括号长度
2. **两种情况**：
   - `...()` - 直接配对
   - `...))` - 需要跳过中间的有效部分找匹配
3. **以 `'('` 结尾**：不可能是有效括号，`dp[i] = 0`

### 状态转移：

**情况1：`s[i-1]='('` 且 `s[i]=')'`** → 形成 `...()`
```
dp[i] = dp[i-2] + 2
        ^^^^^^^^   ^
        前面的    当前配对
```

**情况2：`s[i-1]=')'` 且 `s[i]=')'`** → 形成 `...))`
- 跳过中间 `dp[i-1]` 长度的有效部分
- 检查 `s[i - dp[i-1] - 1]` 是否是 `'('`
- 如果是，可以匹配

```
dp[i] = dp[i-1] + 2 + dp[i - dp[i-1] - 2]
        ^^^^^^^^   ^   ^^^^^^^^^^^^^^^^^^^
        中间的    当前    前面连续的
        有效长度  配对    有效长度
```

### 算法流程示例：

```
输入: "()(())"
索引:  012345

i=1: ')', '(' + ')' → 情况1
     dp[1] = 0 + 2 = 2

i=2: '(', 跳过

i=3: '(', 跳过

i=4: ')', '(' + ')' → 情况1
     dp[4] = dp[2] + 2 = 0 + 2 = 2

i=5: ')', ')' + ')' → 情况2
     prevLength = dp[4] = 2
     s[5-2-1] = s[2] = '(' ✓ 可以匹配
     dp[5] = 2 + 2 + dp[1] = 2 + 2 + 2 = 6

结果: maxLength = 6
```

### 复杂度：
- 时间：O(n)，单次遍历
- 空间：O(n)，dp 数组

```java
class Solution {
    public int longestValidParentheses(String s) {
        char[] c = s.toCharArray();
        int n = c.length;
        int maxLength = 0;
        int[] dp = new int[n + 1];  // dp[i] = 以 i 结尾的最长有效括号长度
        
        for (int i = 1; i < n; i++) {
            int prevLength = dp[i - 1];
            
            // 以 '(' 结尾不可能是有效括号
            if (c[i] == '(') {
                continue;
            }
            
            if (c[i - 1] == '(') {
                // 情况1: xxxx() - 直接配对
                dp[i] = (i - 2 >= 0 ? dp[i - 2] : 0) + 2;
            } else if (prevLength > 0 && i - prevLength - 1 >= 0 && c[i - prevLength - 1] == '(') {
                // 情况2: yyyy(xxxx)) - 跳过中间有效部分找匹配
                // prevLength 是中间有效部分的长度
                dp[i] = prevLength + 2 + ((i - prevLength - 2) >= 0 ? dp[i - prevLength - 2] : 0);
            }
            
            maxLength = Math.max(maxLength, dp[i]);
        }
        
        return maxLength;
    }
}
```

## 856. [Score of Parentheses](https://leetcode.com/problems/score-of-parentheses/)

### 题目描述
给定一个平衡括号字符串 `s`，按照以下规则计算得分：
- `()` 得 1 分
- `AB` 得 `A + B` 分，其中 A 和 B 是平衡括号字符串
- `(A)` 得 `2 * A` 分，其中 A 是平衡括号字符串

例如：`"()"` 得分为 1，`"(())"` 得分为 2，`"()()"` 得分为 2，`"(()(()))"` 得分为 6。

### 核心思想
使用**栈来跟踪每个嵌套层级的累计分数**。栈中存储的是当前层级的累计得分，遇到 `(` 开始新层（压入 0），遇到 `)` 结束当前层并计算得分累加到上一层。

### 关键点
1. **栈底初始化为 0**：代表最外层的累计分数
2. **遇到 `(`**：压入 0，表示开始新的嵌套层，当前层分数为 0
3. **遇到 `)`**：结束当前层
   - `cur = stack.pop()`：弹出当前层的分数
   - `prev = stack.pop()`：弹出上一层的累计分数
   - `Math.max(cur * 2, 1)`：
     - 若 `cur = 0`（即刚才是 `()`），则得分为 1
     - 若 `cur > 0`（即刚才是 `(A)`），则得分为 `cur * 2`
   - 将新得分加到上一层并压回栈

### 执行过程示例
对于字符串 `"(()(()))"` 的执行过程：

```
字符  栈的变化               说明
初始  [0]                   栈底为最外层累计分数
(     [0, 0]               开始外层括号
(     [0, 0, 0]            开始第一个内层括号
)     [0, 1]               () = 1，累加到外层：0+1=1
(     [0, 1, 0]            开始第二个内层括号
(     [0, 1, 0, 0]         开始更深一层括号
)     [0, 1, 1]            () = 1，累加：0+1=1
)     [0, 3]               (()) = 1*2 = 2，累加：1+2=3
)     [6]                  (()(()))的分数 = 3*2 = 6，累加：0+6=6
结果  6
```

### 复杂度分析
- **时间复杂度**：$O(n)$，遍历字符串一次
- **空间复杂度**：$O(n)$，栈的最大深度等于括号的最大嵌套层数

```java
import java.util.LinkedList;

class Solution {
    public int scoreOfParentheses(String s) {
        LinkedList<Integer> stack = new LinkedList<>();
        stack.push(0);  // 栈底初始化为0，代表最外层累计分数
        
        for (char c : s.toCharArray()) {
            if (c == '(') {
                stack.push(0);  // 开始新的嵌套层，压入0
            } else {
                int cur = stack.pop();   // 当前层的分数
                int prev = stack.pop();  // 上一层的累计分数
                // 如果cur=0说明是()，得1分；否则是(A)，得2*A分
                // 然后累加到上一层
                int newPrev = Math.max(cur * 2, 1) + prev;
                stack.push(newPrev);
            }
        }
        
        return stack.pop();  // 返回最外层的总分
    }
}
```

## 921. [Minimum Add to Make Parentheses Valid](https://leetcode.com/problems/minimum-add-to-make-parentheses-valid/)

### 题目描述
给定一个由 `'('` 和 `')'` 组成的字符串 `s`，你需要添加最少的括号使得括号字符串变为有效。返回需要添加的最少括号数。

例如：
- `"())"` → 添加 1 个 `'('` → 结果为 1
- `"((("` → 添加 3 个 `')'` → 结果为 3
- `"())(("` → 添加 2 个 `'('` 和 2 个 `')'` → 结果为 4

### 核心思想
使用**栈来匹配括号**，将所有无法配对的括号都留在栈中。最终栈的大小就是需要添加的括号数量。

### 关键点
1. **遇到 `'('`**：直接压栈，等待后续的 `')'` 来匹配
2. **遇到 `')'`**：
   - 如果栈顶是 `'('`，配对成功，弹出栈顶
   - 如果栈空或栈顶不是 `'('`，说明这个 `')'` 无法匹配，也压栈
3. **最终栈中剩余的字符**都是无法匹配的，每个都需要添加一个对应的括号

### 执行过程示例
对于字符串 `"()))(("` 的执行过程：

```
字符  栈的变化           说明
初始  []                
(     ['(']             压栈，等待匹配
)     []                栈顶是'('，配对成功，弹出
)     [')']             栈空，无法匹配，压栈
)     [')', ')']        栈顶是')'，无法匹配，压栈
(     [')', ')', '(']   压栈，等待匹配
(     [')', ')', '(', '(']  压栈，等待匹配
结果  栈大小 = 4，需要添加 4 个括号
```

解释：
- 2 个 `')'` 需要在前面添加 2 个 `'('`
- 2 个 `'('` 需要在后面添加 2 个 `')'`

### 复杂度分析
- **时间复杂度**：$O(n)$，遍历字符串一次
- **空间复杂度**：$O(n)$，最坏情况下所有字符都无法匹配

```java
import java.util.LinkedList;

class Solution {
    public int minAddToMakeValid(String s) {
        LinkedList<Character> stack = new LinkedList<>();

        for (char c : s.toCharArray()) {
            if (c == '(') {
                stack.push(c);  // '(' 压栈，等待匹配
            }
            if (c == ')') {
                // 如果栈顶是 '('，配对成功，弹出
                if (stack.size() != 0 && stack.getFirst() == '(') {
                    stack.pop();
                } else {
                    // 否则 ')' 无法匹配，也压栈
                    stack.push(c);
                }
            }
        }
        // 栈中剩余的都是无法匹配的括号
        return stack.size();
    }
}
```
