# Heaps & Priority Queue

## 215. [Kth Largest](https://leetcode.com/problems/kth-largest-element-in-an-array/)
```java
import java.util.PriorityQueue;

class Solution {
    public int findKthLargest(int[] nums, int k) {
        // 创建容量为 k 的最小堆
        PriorityQueue<Integer> priorityQueue = new PriorityQueue<>(k);

        for (int num : nums) {
            if (priorityQueue.size() < k) {
                priorityQueue.add(num);
            } else if (priorityQueue.peek() < num) {
                priorityQueue.poll();
                priorityQueue.add(num);
            }
        }
        // 返回第 k 大的元素
        return priorityQueue.peek();
    }
}
```

## 295. [Find Median from Data Stream](https://leetcode.com/problems/find-median-from-data-stream/)
```java
import java.util.PriorityQueue;

public class MedianFinder {

    // min_1 --- maxHeap --- max_1, min_2 --- minHeap --- max_2
    PriorityQueue<Integer> maxHeap = new PriorityQueue<>((a, b) -> b - a);
    PriorityQueue<Integer> minHeap = new PriorityQueue<>();

    // if the total count is Odd, make the middle one at the top of the maxHeap
    public void addNum(int num) {
        if (maxHeap.isEmpty() || num <= maxHeap.peek()) {
            maxHeap.offer(num);
        } else {
            minHeap.offer(num);
        }
        // if count of minHeap is more than maxHeap's, move the min one of minHeap to the maxHeap
        // move the min_2 to max_1
        if (maxHeap.size() > minHeap.size() + 1) {
            minHeap.offer(maxHeap.poll());
        } else if (minHeap.size() > maxHeap.size()) {
            maxHeap.offer(minHeap.poll());
        }
    }

    /**
     * every time, we can get max_1 and min_2, and get the average of them
     * @return
     */
    public double findMedian() {
        if (minHeap.size() == maxHeap.size()) {
            return (minHeap.peek() + maxHeap.peek()) / 2.0;
        } else {
            return maxHeap.peek();
        }
    }
}
```

## 347. [Top K Frequent](https://leetcode.com/problems/top-k-frequent-elements/)
```java
import java.util.HashMap;
import java.util.Map.Entry;
import java.util.PriorityQueue;

class Solution {
    public int[] topKFrequent(int[] nums, int k) {
        HashMap<Integer, Integer> map = new HashMap<>();
        for (int n : nums) {
            int count = map.getOrDefault(n, 0);
            map.put(n, count + 1);
        }
        // array[0]: num, array[1]: frequent
        PriorityQueue<int[]> pq = new PriorityQueue<>((a, b) -> a[1] - b[1]);
        for (Entry<Integer, Integer> entry : map.entrySet()) {
            if (pq.size() < k) {
                pq.offer(new int[] {entry.getKey(), entry.getValue()});
            } else if (pq.peek()[1] < entry.getValue()) {
                pq.poll();
                pq.offer(new int[] {entry.getKey(), entry.getValue()});
            }
        }
        int[] result = new int[k];
        for (int i = result.length - 1; i >= 0; i--) {
            result[i] = pq.poll()[0];
        }
        return result;
    }
}
```

## 378. [Kth Smallest in Sorted Matrix](https://leetcode.com/problems/kth-smallest-element-in-a-sorted-matrix/)
```java
import java.util.PriorityQueue;

class Solution {
    // ask for k smallest, define a maxHeap, top of the pq is the k smallest one
    public int kthSmallest(int[][] matrix, int k) {
        PriorityQueue<Integer> pq = new PriorityQueue<Integer>((a, b) -> b - a);;
        for (int[] list : matrix) {
            for (int num : list) {
                if (pq.size() < k) {
                    pq.offer(num);
                } else if (pq.peek() > num) {
                    pq.poll();
                    pq.offer(num);
                }
            }
        }
        return pq.peek();
    }
}
```

## 1438. [Longest Subarray ≤ limit](https://leetcode.com/problems/longest-continuous-subarray-with-absolute-diff-less-than-or-equal-to-limit/)
```java
import java.util.ArrayDeque;
import java.util.Deque;

class Solution {
    public int longestSubarray(int[] nums, int limit) {
        // to store the min and max from the window between l and right
        Deque<Integer> minQueue = new ArrayDeque<>();
        Deque<Integer> maxQueue = new ArrayDeque<>();
        int result = 0;
        int l = 0;
        for (int r = 0; r < nums.length; r++) {
            // maintain the minQueue is ordered by asc with index
            while (!minQueue.isEmpty() && nums[minQueue.getLast()] > nums[r]) {
                minQueue.removeLast();
            }
            minQueue.addLast(r);
            // maintain the maxQueue is ordered by desc with index
            while (!maxQueue.isEmpty() && nums[maxQueue.getLast()] < nums[r]) {
                maxQueue.removeLast();
            }
            maxQueue.addLast(r);

            while (!minQueue.isEmpty() && !maxQueue.isEmpty()
                    && nums[maxQueue.getFirst()] - nums[minQueue.getFirst()] > limit) {
                if (!maxQueue.isEmpty() && maxQueue.getFirst() == l) {
                    maxQueue.removeFirst();
                }
                if (!minQueue.isEmpty() && minQueue.getFirst() == l) {
                    minQueue.removeFirst();
                }
                l++;
            }
            result = Math.max(result, r - l + 1);
        }

        return result;
    }
}
```

## 23. [Merge k Sorted Lists](https://leetcode.com/problems/merge-k-sorted-lists/)
```java

```

## 502. [IPO](https://leetcode.com/problems/ipo/)
```java

```

## 621. [Task Scheduler](https://leetcode.com/problems/task-scheduler/)
```java

```
