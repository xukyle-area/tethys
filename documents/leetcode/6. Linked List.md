# Linked List
## 206. [Reverse Linked List](https://leetcode.com/problems/reverse-linked-list/description/)

### 题目描述
给定单链表的头节点 `head`，反转链表，并返回反转后的链表。

例如：`[1,2,3,4,5]` → `[5,4,3,2,1]`

### 核心思想
使用**三指针法**。维护三个指针 `prev`、`cur`、`next`，遍历链表的同时反转每个节点的指针方向。

### 关键点
1. **三个指针**：
   - `prev`：前一个节点（初始为 `null`）
   - `cur`：当前节点（从 `head` 开始）
   - `next`：下一个节点（用于保存 `cur.next`）
2. **反转操作**：`cur.next = prev`
3. **指针前移**：`prev = cur`, `cur = next`
4. **返回值**：最后 `prev` 指向新的头节点

### 执行过程示例
对于 `1 -> 2 -> 3 -> null`：
```
初始：prev=null, cur=1->2->3

第1次：
next = 2
1.next = null    → 1 -> null
prev = 1, cur = 2

第2次：
next = 3
2.next = 1       → 2 -> 1 -> null
prev = 2, cur = 3

第3次：
next = null
3.next = 2       → 3 -> 2 -> 1 -> null
prev = 3, cur = null

返回 prev = 3
```

### 复杂度分析
- **时间复杂度**：$O(n)$，遍历链表一次
- **空间复杂度**：$O(1)$，只使用常数个指针

```java
class Solution {
    public ListNode reverseList(ListNode head) {
        ListNode prev = null;  // 前一个节点
        ListNode cur = head;   // 当前节点
        
        while (cur != null) {
            ListNode temp = cur.next;  // 保存下一个节点
            cur.next = prev;           // 反转指针
            prev = cur;                // prev 前移
            cur = temp;                // cur 前移
        }
        
        return prev;  // prev 是新的头节点
    }
}
```
## 141. [Linked List Cycle](https://leetcode.com/problems/linked-list-cycle/)

### 题目描述
给定链表的头节点 `head`，判断链表中是否有环。如果链表中某个节点可以通过连续跟踪 `next` 指针再次到达，则链表中存在环。

### 方法1：哈希表法

#### 核心思想
使用 `HashSet` 记录访问过的节点。如果遇到已经访问过的节点，说明有环。

#### 关键点
1. 遍历链表，将每个节点加入 `HashSet`
2. 如果当前节点已在集合中，返回 `true`
3. 如果遍历到 `null`，返回 `false`

#### 复杂度分析
- **时间复杂度**：$O(n)$，最多遍历所有节点
- **空间复杂度**：$O(n)$，哈希表存储所有节点

```java
import java.util.HashSet;

public class Solution {
    public boolean hasCycle(ListNode head) {
        HashSet<ListNode> set = new HashSet<ListNode>();
        ListNode cur = head;
        
        while (cur != null) {
            if (set.contains(cur)) {  // 遇到访问过的节点
                return true;
            }
            set.add(cur);  // 记录当前节点
            cur = cur.next;
        }
        
        return false;  // 遍历完没有环
    }
}
```

### 方法2：快慢指针（推荐）

#### 核心思想
使用**快慢指针**（Floyd判圈算法）。快指针每次走2步，慢指针每次走1步。如果有环，快指针最终会追上慢指针。

#### 关键点
1. `slow` 每次走1步，`fast` 每次走2步
2. 如果 `fast` 到达 `null`，说明无环
3. 如果 `slow == fast`，说明有环

#### 复杂度分析
- **时间复杂度**：$O(n)$
- **空间复杂度**：$O(1)$ ✅ 更优

```java
public class Solution {
    public boolean hasCycle(ListNode head) {
        if (head == null) return false;
        
        ListNode slow = head;
        ListNode fast = head;
        
        while (fast != null && fast.next != null) {
            slow = slow.next;       // 慢指针走1步
            fast = fast.next.next;  // 快指针走2步
            
            if (slow == fast) {     // 相遇说明有环
                return true;
            }
        }
        
        return false;  // fast到达末尾，无环
    }
}
```

## 142. [Linked List Cycle II](https://leetcode.com/problems/linked-list-cycle-ii/)

### 题目描述
给定链表的头节点 `head`，返回链表开始入环的第一个节点。如果链表无环，返回 `null`。

### 核心思想
使用**快慢指针 + 数学推导**。分两个阶段：
1. **阶段1**：快慢指针相遇，确认有环
2. **阶段2**：一个指针从头开始，一个从相遇点开始，再次相遇点即为入环点

### 数学原理
设：
- 链表头到入环点距离：`a`
- 入环点到相遇点距离：`b`
- 相遇点到入环点距离：`c`（环的剩余部分）

**第一次相遇时**：
- 慢指针走了：`a + b`
- 快指针走了：`a + b + c + b`（多走了一圈）
- 因为快指针速度是慢指针2倍：`2(a + b) = a + b + c + b`
- 化简得：**`a = c`**

因此，从头节点和相遇点同时出发，相遇点就是入环点！

### 关键点
1. **阶段1**：快慢指针找相遇点
2. **阶段2**：一个从 `head`，一个从相遇点，同速前进
3. **数学保证**：它们会在入环点相遇

### 执行过程图解
```
链表：0 -> 1 -> 2 -> 3 -> 4
                ↑         ↓
                7 <- 6 <- 5

a = 2 (0->1->2)
环：2->3->4->5->6->7->2

第一次相遇（假设在节点5）：
slow: 0->1->2->3->4->5
fast: 0->1->2->3->4->5->6->7->2->3->4->5

第二次相遇（入环点2）：
ptr1: 0->1->2
ptr2: 5->6->7->2
```

### 复杂度分析
- **时间复杂度**：$O(n)$，最多遍历链表两次
- **空间复杂度**：$O(1)$，只用两个指针

```java
public class Solution {
    public ListNode detectCycle(ListNode head) {
        ListNode fast = head;
        ListNode slow = head;
        
        // 阶段1：快慢指针找相遇点
        while (true) {
            if (fast == null) return null;
            fast = fast.next;
            if (fast == null) return null;
            fast = fast.next;  // 快指针走2步
            
            slow = slow.next;  // 慢指针走1步
            
            if (slow == fast) {  // 相遇，有环
                break;
            }
        }
        
        // 阶段2：一个从头，一个从相遇点，同速前进
        fast = head;
        while (fast != slow) {
            fast = fast.next;
            slow = slow.next;
        }
        
        return slow;  // 相遇点即入环点
    }
}
```

## 21. [Merge Two Sorted Lists](https://leetcode.com/problems/merge-two-sorted-lists/)

### 题目描述
将两个升序链表合并为一个新的升序链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。

例如：`list1 = [1,2,4]`, `list2 = [1,3,4]` → `[1,1,2,3,4,4]`

### 核心思想
使用**虚拟头节点 + 双指针**。比较两个链表的当前节点，将较小的节点接到结果链表上。

### 关键点
1. **虚拟头节点**：简化边界处理，避免特殊判断
2. **双指针遍历**：`cur1` 和 `cur2` 分别遍历两个链表
3. **比较逻辑**：
   - 如果一个为空，直接接另一个
   - 否则比较值的大小，选较小的
4. **边界处理**：当一个链表遍历完，另一个可能还有剩余

### 执行过程示例
对于 `list1=[1,2,4]`, `list2=[1,3,4]`：
```
virtual -> null
cur1=1, cur2=1    → 1>=1, 选cur2  → virtual->1
cur1=1, cur2=3    → 1<3,  选cur1  → 1->1
cur1=2, cur2=3    → 2<3,  选cur1  → 1->1->2
cur1=4, cur2=3    → 4>=3, 选cur2  → 1->1->2->3
cur1=4, cur2=4    → 4>=4, 选cur2  → 1->1->2->3->4
cur1=4, cur2=null → 选cur1  → 1->1->2->3->4->4
结果：[1,1,2,3,4,4]
```

### 复杂度分析
- **时间复杂度**：$O(m + n)$，遍历两个链表一次
- **空间复杂度**：$O(1)$，只使用常数个指针

```java
class Solution {
    public ListNode mergeTwoLists(ListNode list1, ListNode list2) {
        ListNode virtualNode = new ListNode();  // 虚拟头节点
        ListNode cur = virtualNode;             // 当前节点
        ListNode cur1 = list1;
        ListNode cur2 = list2;
        
        while (cur1 != null || cur2 != null) {
            // cur1为空或cur2更小，选cur2
            if (cur1 == null || (cur2 != null && cur1.val >= cur2.val)) {
                cur.next = cur2;
                cur = cur.next;
                cur2 = cur2.next;
            } 
            // cur2为空或cur1更小，选cur1
            else if (cur2 == null || (cur1 != null && cur1.val < cur2.val)) {
                cur.next = cur1;
                cur = cur.next;
                cur1 = cur1.next;
            }
        }
        
        return virtualNode.next;
    }
}

## 23. [Merge k Sorted Lists](https://leetcode.com/problems/merge-k-sorted-lists/)
```java

```

## 19. [Remove Nth Node From End of List](https://leetcode.com/problems/remove-nth-node-from-end-of-list/)

### 题目描述
给定一个链表，删除链表的倒数第 `n` 个节点，并返回链表的头节点。

例如：`head = [1,2,3,4,5]`, `n = 2` → `[1,2,3,5]`（删除4）

### 方法1：两次遍历（当前实现）

#### 核心思想
第一次遍历计算链表长度，第二次遍历到倒数第 `n` 个节点的前一个，删除目标节点。

#### 关键点
1. **计算长度**：第一次遍历得到 `count`
2. **计算位置**：倒数第n个 = 正数第 `count - n + 1` 个
3. **删除操作**：`prev.next = prev.next.next`
4. **边界处理**：如果删除的是头节点，直接返回 `head.next`

#### 复杂度分析
- **时间复杂度**：$O(n)$，遍历两次
- **空间复杂度**：$O(1)$

```java
class Solution {
    public ListNode removeNthFromEnd(ListNode head, int n) {
        // 第一次遍历：计算链表长度
        ListNode iter = head;
        int count = 0;
        while (iter != null) {
            iter = iter.next;
            count++;
        }
        
        // 计算要删除节点的位置（从0开始）
        int toDelete = count - n;
        
        // 边界情况：删除头节点
        if (toDelete == 0) {
            return head.next;
        }
        
        // 第二次遍历：找到要删除节点的前一个
        iter = head;
        count = 0;
        while (iter != null) {
            if (count == toDelete - 1) {
                iter.next = iter.next.next;  // 删除
                break;
            }
            iter = iter.next;
            count++;
        }
        
        return head;
    }
}
```

### 方法2：一次遍历（快慢指针）

#### 核心思想
使用两个指针，快指针先走 `n` 步，然后两个指针同时移动。当快指针到达末尾时，慢指针正好在要删除节点的前一个。

#### 关键点
1. **虚拟头节点**：处理删除头节点的情况
2. **快指针先行**：`fast` 先走 `n+1` 步
3. **同步移动**：`fast` 和 `slow` 一起移动直到 `fast` 为空
4. **删除操作**：`slow.next = slow.next.next`

#### 复杂度分析
- **时间复杂度**：$O(n)$，只遍历一次 ✅ 更优
- **空间复杂度**：$O(1)$

```java
class Solution {
    public ListNode removeNthFromEnd(ListNode head, int n) {
        ListNode dummy = new ListNode(0);
        dummy.next = head;
        ListNode fast = dummy;
        ListNode slow = dummy;
        
        // 快指针先走 n+1 步
        for (int i = 0; i <= n; i++) {
            fast = fast.next;
        }
        
        // 同步移动直到fast到达末尾
        while (fast != null) {
            fast = fast.next;
            slow = slow.next;
        }
        
        // slow在要删除节点的前一个
        slow.next = slow.next.next;
        
        return dummy.next;
    }
}
```

## 24. [Swap Nodes in Pairs](https://leetcode.com/problems/swap-nodes-in-pairs/)

### 题目描述
给定一个链表，两两交换其中相邻的节点，并返回交换后的链表。不能只是单纯的改变节点内部的值，而是需要实际进行节点交换。

例如：`[1,2,3,4]` → `[2,1,4,3]`

### 核心思想
使用**虚拟头节点 + 节点交换函数**。每次交换一对相邻节点，通过调整指针完成交换。

### 关键点
1. **虚拟头节点**：简化头节点的处理
2. **交换逻辑**：对于节点 `l -> a -> b -> c`：
   ```
   l.next = b
   b.next = a
   a.next = c
   ```
3. **边界检查**：确保 `a` 和 `b` 都存在
4. **指针移动**：每次交换后，`cur` 移动到下一对的前一个节点

### 执行过程示例
对于 `[1,2,3,4]`：
```
初始：virtual -> 1 -> 2 -> 3 -> 4

第1次交换（l=virtual, a=1, b=2, c=3）：
virtual.next = 2    → virtual -> 2
2.next = 1          → 2 -> 1
1.next = 3          → 1 -> 3
结果：virtual -> 2 -> 1 -> 3 -> 4

第2次交换（l=1, a=3, b=4, c=null）：
1.next = 4          → 1 -> 4
4.next = 3          → 4 -> 3
3.next = null       → 3 -> null
结果：virtual -> 2 -> 1 -> 4 -> 3

最终：[2,1,4,3]
```

### 复杂度分析
- **时间复杂度**：$O(n)$，遍历链表一次
- **空间复杂度**：$O(1)$，只使用常数个指针

```java
class Solution {
    public ListNode swapPairs(ListNode head) {
        ListNode virtualNode = new ListNode();
        virtualNode.next = head;
        ListNode cur = virtualNode;
        
        // 每次处理一对节点
        while (cur.next != null && cur.next.next != null) {
            swap(cur);
            cur = cur.next.next;  // 移动到下一对的前一个
        }
        
        return virtualNode.next;
    }

    // 交换 l 后面的两个节点
    private void swap(ListNode l) {
        ListNode a = l.next;
        if (a == null) return;      // 无节点，不交换
        
        ListNode b = a.next;
        if (b == null) return;      // 只有一个节点，不交换
        
        ListNode c = b.next;

        // 交换三步骤
        l.next = b;    // l 指向 b
        b.next = a;    // b 指向 a
        a.next = c;    // a 指向 c
    }
}

## 25. [Reverse Nodes in k-Group](https://leetcode.com/problems/reverse-nodes-in-k-group/)
```java

```

## 92. [Reverse Linked List II](https://leetcode.com/problems/reverse-linked-list-ii/)

### 题目描述
给定一个单链表的头节点 `head` 和两个整数 `left` 和 `right`（`1 <= left <= right <= n`），反转从位置 `left` 到位置 `right` 的链表节点，返回反转后的链表。

例如：`head = [1,2,3,4,5]`, `left = 2`, `right = 4` → 输出 `[1,4,3,2,5]`

**要求**：只遍历链表一次完成反转。

### 核心思想
使用**头插法**进行部分反转。与传统的三指针反转不同，这里采用"不断将当前节点的下一个节点摘出来，插入到反转段的头部"的策略。

**关键理解**：
1. `prev` 指向反转段的前一个节点（固定不动）
2. `cur` 指向反转段的第一个节点（固定不动，最终成为反转段的尾部）
3. 每次操作将 `cur.next` 摘出来插到 `prev` 后面

### 关键点
1. **虚拟头节点**：处理 `left = 1` 的边界情况
2. **两阶段操作**：
   - 第一阶段：移动 `prev` 到 `left-1` 位置
   - 第二阶段：执行 `right - left` 次头插操作
3. **头插法的三步骤**（核心循环）：
   ```
   a) cur.next = next.next      // cur 跳过 next 节点
   b) next.next = prev.next     // next 指向反转段当前的头部
   c) prev.next = next          // next 成为新的反转段头部
   ```
4. **指针不回退**：`prev` 和 `cur` 始终不变，只有 `cur.next` 不断被摘除和插入

### 执行过程示例
对于 `head = [1,2,3,4,5]`, `left = 2`, `right = 4`：

```
初始状态：
dummy -> 1 -> 2 -> 3 -> 4 -> 5
        prev  cur

第1次迭代（i=0）：摘出节点3，插到prev后面
步骤1: cur.next = 3.next        → 2 -> 4
步骤2: 3.next = prev.next       → 3 -> 2
步骤3: prev.next = 3            → 1 -> 3
结果：dummy -> 1 -> 3 -> 2 -> 4 -> 5
              prev       cur

第2次迭代（i=1）：摘出节点4，插到prev后面
步骤1: cur.next = 4.next        → 2 -> 5
步骤2: 4.next = prev.next       → 4 -> 3
步骤3: prev.next = 4            → 1 -> 4
结果：dummy -> 1 -> 4 -> 3 -> 2 -> 5
              prev            cur

最终结果：[1, 4, 3, 2, 5]
```

**关键观察**：
- `cur`（节点2）始终在原位置，最终成为反转段的尾部
- `prev`（节点1）始终不动，始终指向反转段的前驱
- 每次迭代把 `cur` 的下一个节点摘出来插到最前面

### 对比：三种反转方法

#### 方法1：传统三指针反转（全链表）
```java
ListNode prev = null;
ListNode cur = head;
while (cur != null) {
    ListNode next = cur.next;
    cur.next = prev;    // 反转指针
    prev = cur;         // 三个指针都前移
    cur = next;
}
return prev;
```
**特点**：
- 三个指针 `prev`、`cur`、`next` 都在移动
- 直接反转指针方向
- 适用场景：整个链表反转

---

#### 方法2：一般头插法（全链表）
```java
ListNode dummy = new ListNode();
ListNode cur = head;
while (cur != null) {
    ListNode next = cur.next;    // 保存下一个节点
    cur.next = dummy.next;       // cur 插到 dummy 后面
    dummy.next = cur;            // 更新 dummy.next
    cur = next;                  // cur 移动到下一个节点
}
return dummy.next;
```
**特点**：
- `cur` **移动**，遍历整个链表
- 每次把 `cur` 本身摘下来插到新链表头部
- `dummy` 是新链表的虚拟头节点
- 适用场景：整个链表反转（头插法实现）

---

#### 方法3：部分反转头插法（本题使用）
```java
ListNode cur = prev.next;  // cur 固定在 left 位置
for (int i = 0; i < right - left; i++) {
    ListNode next = cur.next;
    cur.next = next.next;      // cur 跳过 next
    next.next = prev.next;     // next 插到 prev 后面
    prev.next = next;          // next 成为新的反转段头部
}
```
**特点**：
- `cur` **不移动**，固定在 left 位置
- 每次把 `cur.next` 摘出来插到 `prev` 后面
- `prev` 是反转段的前驱节点（不是新链表）
- **核心优势**：自动保持前后连接，无需额外拼接！
- 适用场景：部分链表反转

---

#### 关键区别图解

**一般头插法（方法2）**：人在动，自己跳进新链表
```
dummy -> null
cur → 1 → 2 → 3      // cur 自己跳到 dummy 后

dummy → 1 → null
cur → 2 → 3          // cur 继续跳

dummy → 2 → 1 → null
cur → 3              // 最终全部反转
```

**部分反转头插法（方法3）**：人不动，摘果子插前面
```
prev → 2 → 3 → 4 → 5
       cur (不动)

prev → 3 → 2 → 4 → 5    // 把 3 摘出来插前面
            cur (还在原位)

prev → 4 → 3 → 2 → 5    // 把 4 摘出来插前面
                 cur (还在原位，成为反转段尾部)
```

**为什么部分反转要用方法3？**
- `cur` 固定 → 自动成为反转段的**尾部**，保持与后续节点的连接
- `prev` 固定 → 保持与前面节点的连接
- 无需记录和重新拼接前后段，一气呵成！

### 复杂度分析
- **时间复杂度**：$O(n)$，遍历链表一次，其中 $n$ 是链表长度
- **空间复杂度**：$O(1)$，只使用常数个指针变量

```java
class Solution {
    public ListNode reverseBetween(ListNode head, int left, int right) {
        ListNode dummy = new ListNode(0);
        dummy.next = head;
        ListNode prev = dummy;
        // 移动到 left 的前一个
        int count = 1;
        for (; count < left; count++) {
            prev = prev.next;
        }
        ListNode iter = prev.next;

        // 移动 next (iter.next) 到 prev 后
        for (; count < right; count++) {
            // 遍历移动
            ListNode next = iter.next;
            iter.next = next.next;
            // 处理链表连接
            next.next = prev.next;
            prev.next = next;
        }
        return dummy.next;
    }
}
```

## 234. [Palindrome Linked List](https://leetcode.com/problems/palindrome-linked-list/)

### 题目描述
给定一个单链表的头节点 `head`，判断该链表是否为回文链表。

例如：`[1,2,2,1]` → `true`，`[1,2,3,2,1]` → `true`

### 核心思想
使用**快慢指针找中点 + 反转后半部分 + 比较**。将链表后半部分反转，然后与前半部分逐个比较。

### 关键点
1. **找中点**：使用快慢指针，`slow` 到达中间位置
   - 奇数长度：`slow` 在中间节点
   - 偶数长度：`slow` 在前半段最后一个
2. **反转后半部分**：从 `middle.next` 开始反转
3. **比较两部分**：同时遍历前半和反转后的后半
4. **不需要恢复**：题目不要求恢复原链表

### 执行过程示例
对于 `[1,2,3,2,1]`：
```
原始：1 -> 2 -> 3 -> 2 -> 1

找中点：slow=3, fast=null
middle = 3

反转后半：2 -> 1 反转为 1 -> 2

比较：
前半：1 -> 2 -> 3
后半：1 -> 2

1 == 1 ✓
2 == 2 ✓
后半遍历完，返回 true
```

### 复杂度分析
- **时间复杂度**：$O(n)$，遍历链表三次（找中点、反转、比较）
- **空间复杂度**：$O(1)$，原地操作

```java
class Solution {
    // 找到链表的中间节点
    public ListNode findmiddle(ListNode head) {
        ListNode slow = head;
        ListNode fast = head;
        
        // fast.next.next 保证fast不会越界
        while (fast.next != null && fast.next.next != null) {
            slow = slow.next;       // 慢指针走1步
            fast = fast.next.next;  // 快指针走2步
        }
        
        return slow;  // slow在中间位置
    }

    // 反转链表
    public ListNode reverse(ListNode head) {
        ListNode prev = null;
        ListNode curr = head;

        while (curr != null) {
            ListNode next = curr.next;
            curr.next = prev;  // 反转指针
            prev = curr;
            curr = next;
        }
        
        return prev;
    }

    public boolean isPalindrome(ListNode head) {
        // 边界情况
        if (head == null || head.next == null) {
            return true;
        }
        
        // 1. 找到中间节点
        ListNode middle = findmiddle(head);
        
        // 2. 反转后半部分
        ListNode secondhalfstart = reverse(middle.next);
        
        // 3. 比较前半和反转后的后半
        ListNode firsthalfstart = head;
        while (secondhalfstart != null) {
            if (firsthalfstart.val != secondhalfstart.val) {
                return false;
            }
            firsthalfstart = firsthalfstart.next;
            secondhalfstart = secondhalfstart.next;
        }
        
        return true;
    }
}

## 143. [Reorder List](https://leetcode.com/problems/reorder-list/)

### 题目描述
给定一个单链表 `L0 → L1 → … → Ln-1 → Ln`，将其重新排列为：`L0 → Ln → L1 → Ln-1 → L2 → Ln-2 → …`

例如：`[1,2,3,4,5]` → `[1,5,2,4,3]`

### 核心思想
使用**找中点 + 反转后半部分 + 交替合并**。将链表分为两部分，反转后半部分，然后交替合并两个链表。

### 关键点
1. **找中点**：快慢指针找到中间位置
2. **断开链表**：`slow.next = null` 将链表分为两部分
3. **反转后半**：使用三指针反转
4. **交替合并**：依次从两个链表中取节点

### 执行过程示例
对于 `[1,2,3,4,5]`：
```
步骤1：找中点
1 -> 2 -> 3 -> 4 -> 5
          slow

步骤2：分为两部分
前半：1 -> 2 -> 3
后半：4 -> 5

步骤3：反转后半
前半：1 -> 2 -> 3
后半：5 -> 4

步骤4：交替合并
取1: 1 -> 5
取2: 5 -> 2
取4: 2 -> 4
取3: 4 -> 3

结果：1 -> 5 -> 2 -> 4 -> 3
```

### 复杂度分析
- **时间复杂度**：$O(n)$，遍历链表三次
- **空间复杂度**：$O(1)$，原地操作

```java
class Solution {
    public void reorderList(ListNode head) {
        if (head == null || head.next == null) return;
        
        // 1. 快慢指针找中点
        ListNode slow = head, fast = head;
        while (fast.next != null && fast.next.next != null) {
            slow = slow.next;
            fast = fast.next.next;
        }
        
        // 2. 反转后半部分链表
        ListNode second = reverse(slow.next);
        slow.next = null;  // 断开前半部分
        
        // 3. 交替合并两个链表
        ListNode first = head;
        while (second != null) {
            ListNode temp1 = first.next;   // 保存前半下一个
            ListNode temp2 = second.next;  // 保存后半下一个
            
            first.next = second;   // 连接后半节点
            second.next = temp1;   // 连接前半下一个
            
            first = temp1;         // 移动指针
            second = temp2;
        }
    }
    
    // 反转链表
    private ListNode reverse(ListNode head) {
        ListNode prev = null, cur = head;
        while (cur != null) {
            ListNode next = cur.next;
            cur.next = prev;
            prev = cur;
            cur = next;
        }
        return prev;
    }
}