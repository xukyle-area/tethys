# 3. [Longest Substring Without Repeating Characters](https://leetcode.com/problems/longest-substring-without-repeating-characters/description/)

### 题目描述
给定一个字符串 `s`，找出其中不含有重复字符的最长子串的长度。

例如：`"abcabcbb"` → 输出 `3`（子串为 `"abc"`）
`"pwwkew"` → 输出 `3`（子串为 `"wke"`）

### 核心思想
使用**滑动窗口 + 哈希表**记录每个字符最后出现的位置。当遇到重复字符时，将左边界移动到该字符上次出现位置的下一个位置。

### 关键点
1. **哈希表记录位置**：`map[char]` 记录字符 `char` 最后出现的索引
2. **窗口维护**：
   - `left`：左边界
   - `right`：右边界（不断向右扩展）
3. **遇到重复字符**：
   - 如果 `lastIndex >= left`（在当前窗口内），则 `left = lastIndex + 1`
   - 否则说明该字符不在当前窗口内，无需调整
4. **更新最大长度**：`max = max(max, right - left + 1)`

### 执行过程示例
对于 `"abcabcbb"` 的执行过程：

```
right  char  lastIndex  left  窗口       长度  max
0      a     -1         0     [a]        1     1
1      b     -1         0     [ab]       2     2
2      c     -1         0     [abc]      3     3
3      a     0          1     [bca]      3     3
4      b     1          2     [cab]      3     3
5      c     2          3     [abc]      3     3
6      b     4          5     [cb]       2     3
7      b     6          7     [b]        1     3
结果 3
```

### 复杂度分析
- **时间复杂度**：$O(n)$，每个字符最多被访问两次
- **空间复杂度**：$O(1)$，固定大小的字符集（128个ASCII字符）

```java
class Solution {
    public int lengthOfLongestSubstring(String s) {
        int[] map = new int[128];  // 记录每个字符最后出现的位置
        for (int i = 0; i < 128; i++) map[i] = -1;  // 初始化为-1

        int left = 0;   // 窗口左边界
        int right = -1; // 窗口右边界
        int max = 0;    // 最大长度
        
        while (right < s.length() - 1) {
            right++;  // 右边界扩展
            char currentChar = s.charAt(right);
            int lastIndex = map[currentChar];  // 获取该字符上次出现的位置
            map[currentChar] = right;          // 更新当前字符的位置
            
            // 如果该字符在当前窗口内出现过，移动左边界
            if (lastIndex >= left) {
                left = lastIndex + 1;
            }
            
            // 更新最大长度
            max = Math.max(max, right - left + 1);
        }
        return max;
    }
}
```

# 76. [Minimum Window Substring](https://leetcode.com/problems/minimum-window-substring/description/)

### 题目描述
给定两个字符串 `s` 和 `t`，返回 `s` 中涵盖 `t` 所有字符的最小子串。如果不存在，返回空字符串 `""`。

例如：`s = "ADOBECODEBANC"`, `t = "ABC"` → 输出 `"BANC"`

### 核心思想
使用**滑动窗口**。用两个哈希表分别记录 `t` 中字符的频次和当前窗口中字符的频次。右边界不断扩展直到窗口包含 `t` 的所有字符，然后收缩左边界寻找最小窗口。

### 关键点
1. **两个哈希表**：
   - `tCount`：记录 `t` 中每个字符的频次
   - `windowCount`：记录当前窗口中每个字符的频次
2. **窗口扩展**：右边界 `right` 不断右移，更新 `windowCount`
3. **窗口收缩**：当窗口包含所有字符时，左边界 `left` 右移，寻找更小的窗口
4. **检查函数**：`check()` 验证窗口是否包含 `t` 的所有字符及其频次
5. **记录最小窗口**：每次找到有效窗口时更新最小值

### 复杂度分析
- **时间复杂度**：$O(|s| + |t|)$，每个字符最多被访问两次
- **空间复杂度**：$O(|t|)$，哈希表存储

```java
import java.util.HashMap;
import java.util.Map;
import java.util.Map.Entry;

class Solution {
    public String minWindow(String s, String t) {
        // 记录 t 中每个字符的频次
        Map<Character, Integer> tCount = new HashMap<>();
        for (int i = 0; i < t.length(); i++) {
            char c = t.charAt(i);
            tCount.put(c, tCount.getOrDefault(c, 0) + 1);
        }

        // 记录当前窗口中每个字符的频次
        Map<Character, Integer> windowsCount = new HashMap<>();
        char[] aArray = s.toCharArray();

        int left = 0;
        int right = -1;
        String min = s;
        boolean has = false;  // 标记是否找到过有效窗口
        
        while (right < aArray.length - 1) {
            right++;  // 扩展右边界
            windowsCount.put(aArray[right], windowsCount.getOrDefault(aArray[right], 0) + 1);
            
            // 当窗口包含所有字符时，尝试收缩左边界
            while (this.check(windowsCount, tCount)) {
                has = true;
                // 更新最小窗口
                if (min.length() > right - left + 1) {
                    min = s.substring(left, right + 1);
                }
                // 收缩左边界
                windowsCount.put(aArray[left], windowsCount.getOrDefault(aArray[left], 0) - 1);
                left++;
            }
        }
        return has ? min : "";
    }

    // 检查窗口是否包含 t 的所有字符及其频次
    private boolean check(Map<Character, Integer> windowsCount, Map<Character, Integer> tCount) {
        for (Entry<Character, Integer> entry : tCount.entrySet()) {
            if (windowsCount.getOrDefault(entry.getKey(), 0) < entry.getValue()) {
                return false;
            }
        }
        return true;
    }
}
```

# 567. [Permutation in String](https://leetcode.com/problems/permutation-in-string/description/)

### 题目描述
给定两个字符串 `s1` 和 `s2`，判断 `s2` 是否包含 `s1` 的排列。换句话说，`s2` 中是否存在一个子串包含 `s1` 中所有字符且频次相同。

例如：`s1 = "ab"`, `s2 = "eidbaooo"` → 输出 `true`（`s2` 包含 `"ba"`）

### 核心思想
使用**固定长度滑动窗口**。窗口大小固定为 `s1` 的长度，维护窗口内字符频次，与 `s1` 的字符频次比较。

### 关键点
1. **固定窗口**：窗口大小始终等于 `t.length()`
2. **字符频次数组**：使用数组记录 26 个小写字母的频次
3. **窗口滑动**：
   - 初始化：先填充前 `k` 个字符
   - 滑动：右边界加入新字符，左边界移除旧字符
4. **频次比较**：每次滑动后检查窗口频次是否与 `t` 完全相同

### 复杂度分析
- **时间复杂度**：$O(n)$，n 是 `s` 的长度
- **空间复杂度**：$O(1)$，固定大小的频次数组

```java
class Solution {
    public boolean checkInclusion(String t, String s) {
        int[] tcount = new int[26];  // t 的字符频次
        
        if (t.length() > s.length()) {
            return false;
        }
        
        // 统计 t 中每个字符的频次
        for (int i = 0; i < t.length(); i++) {
            tcount[t.charAt(i) - 'a']++;
        }

        int[] windowsCount = new int[26];  // 窗口字符频次

        int left = 0;
        int right = t.length() - 1;
        
        // 初始化窗口（前 t.length() 个字符）
        for (int i = left; i <= right; i++) {
            windowsCount[s.charAt(i) - 'a']++;
        }
        if (this.check(windowsCount, tcount)) {
            return true;
        }

        // 滑动窗口
        while (right < s.length() - 1) {
            right++;  // 右边界扩展，加入新字符
            windowsCount[s.charAt(right) - 'a']++;
            windowsCount[s.charAt(left) - 'a']--;  // 左边界收缩，移除旧字符
            left++;
            
            if (this.check(windowsCount, tcount)) {
                return true;
            }
        }
        return false;
    }

    // 检查两个频次数组是否完全相同
    private boolean check(int[] windowsCount, int[] tcount) {
        for (int i = 0; i < 26; i++) {
            if (windowsCount[i] != tcount[i]) {
                return false;
            }
        }
        return true;
    }
}
```

# 438. [Find All Anagrams](https://leetcode.com/problems/find-all-anagrams-in-a-string/description/)

### 题目描述
给定两个字符串 `s` 和 `p`，找到 `s` 中所有 `p` 的异位词的子串，返回这些子串的起始索引。异位词指字母相同但排列不同的字符串。

例如：`s = "cbaebabacd"`, `p = "abc"` → 输出 `[0,6]`

### 核心思想
与上一题（567. Permutation in String）几乎相同。使用**固定长度滑动窗口**，每次找到匹配时记录起始索引，而不是直接返回。

### 关键点
1. **固定窗口**：窗口大小等于 `t.length()`
2. **收集所有匹配**：与 567 题的区别在于需要收集所有起始位置
3. **频次比较**：每次滑动后检查是否为异位词
4. **记录索引**：每次匹配时将 `left` 加入结果列表

### 复杂度分析
- **时间复杂度**：$O(n)$，n 是 `s` 的长度
- **空间复杂度**：$O(1)$，固定大小的频次数组（不计结果列表）

```java
import java.util.ArrayList;
import java.util.List;

class Solution {
    public List<Integer> findAnagrams(String s, String t) {
        List<Integer> result = new ArrayList<Integer>();
        int[] tcount = new int[26];
        
        if (t.length() > s.length()) {
            return result;
        }
        
        // 统计 t 中每个字符的频次
        for (int i = 0; i < t.length(); i++) {
            tcount[t.charAt(i) - 'a']++;
        }

        int[] windowsCount = new int[26];

        int left = 0;
        int right = t.length() - 1;
        
        // 初始化窗口
        for (int i = left; i <= right; i++) {
            windowsCount[s.charAt(i) - 'a']++;
        }
        if (this.check(windowsCount, tcount)) {
            result.add(left);  // 记录起始索引
        }

        // 滑动窗口
        while (right < s.length() - 1) {
            right++;  // 右边界扩展
            windowsCount[s.charAt(right) - 'a']++;
            windowsCount[s.charAt(left) - 'a']--;  // 左边界收缩
            left++;
            
            if (this.check(windowsCount, tcount)) {
                result.add(left);  // 记录起始索引
            }
        }
        return result;
    }

    // 检查两个频次数组是否完全相同
    private boolean check(int[] windowsCount, int[] tcount) {
        for (int i = 0; i < 26; i++) {
            if (windowsCount[i] != tcount[i]) {
                return false;
            }
        }
        return true;
    }
}
```

# 239. [Sliding Window Maximum](https://leetcode.com/problems/sliding-window-maximum/description/)

### 题目描述
给定一个整数数组 `nums` 和一个滑动窗口大小 `k`，返回每个滑动窗口中的最大值。

例如：`nums = [1,3,-1,-3,5,3,6,7]`, `k = 3` → 输出 `[3,3,5,5,6,7]`

### 核心思想
使用**单调双端队列（Monotonic Deque）**。队列中保存索引，从队头到队尾对应的元素值保持**单调递减**。队头元素始终是当前窗口的最大值。

### 关键点
1. **单调队列维护**：
   - 队列存储数组索引
   - 保持队列中元素对应的值从大到小排列
2. **队头维护**：移除不在窗口内的索引（`deque.peekFirst() < i - k + 1`）
3. **队尾维护**：移除所有比当前元素小的索引（它们永远不会成为最大值）
4. **记录结果**：当窗口形成后（`i >= k - 1`），队头元素对应的值即为当前窗口最大值

### 执行过程示例
```
nums = [1, 3, -1, -3, 5, 3, 6, 7], k = 3

i=0: deque=[0(1)]
i=1: deque=[1(3)]           // 3>1, 移除索引0
i=2: deque=[1(3), 2(-1)]    // -1<3, 保留
     ans[0] = nums[1] = 3

i=3: deque=[1(3), 2(-1), 3(-3)]
     ans[1] = nums[1] = 3

i=4: deque=[4(5)]           // 5最大, 移除所有
     ans[2] = nums[4] = 5

i=5: deque=[4(5), 5(3)]     // 3<5, 保留
     ans[3] = nums[4] = 5

i=6: deque=[6(6)]           // 6最大, 移除所有
     ans[4] = nums[6] = 6

i=7: deque=[7(7)]           // 7最大, 移除所有
     ans[5] = nums[7] = 7

结果: [3, 3, 5, 5, 6, 7]
```

### 复杂度分析
- **时间复杂度**：$O(n)$，每个元素最多入队和出队各一次
- **空间复杂度**：$O(k)$，双端队列最多存储 k 个元素

```java
import java.util.ArrayDeque;
import java.util.Deque;

class Solution {
    public int[] maxSlidingWindow(int[] nums, int k) {
        int[] ans = new int[nums.length - k + 1];
        Deque<Integer> deque = new ArrayDeque<>(); // 存储索引，保持单调递减

        for (int i = 0; i < nums.length; i++) {
            // 1. 移除不在窗口内的索引
            if (!deque.isEmpty() && deque.peekFirst() < i - k + 1) {
                deque.pollFirst();
            }

            // 2. 移除所有比当前元素小的索引（维护单调递减）
            while (!deque.isEmpty() && nums[deque.peekLast()] < nums[i]) {
                deque.pollLast();
            }

            // 3. 添加当前索引
            deque.offerLast(i);

            // 4. 记录答案（窗口形成后）
            if (i >= k - 1) {
                ans[i - k + 1] = nums[deque.peekFirst()];  // 队头元素即为最大值
            }
        }

        return ans;
    }
}
```

# 424. [Longest Repeating Character Replacement](https://leetcode.com/problems/longest-repeating-character-replacement/description/)

### 题目描述
给定一个字符串 `s` 和一个整数 `k`，可以将任意字符替换成另一个字符，最多替换 `k` 次。找出替换后能获得的最长重复字符串的长度。

例如：`s = "AABABBA"`, `k = 1` → 输出 `4`（将一个 `B` 换成 `A`，得到 `"AAAA"`）

### 核心思想
使用**滑动窗口**。维护窗口内最多出现的字符频次 `maxFreq`。当 `窗口大小 - maxFreq > k` 时，说明需要替换的字符超过 `k` 个，必须收缩窗口。

### 关键点
1. **核心公式**：`窗口大小 - 最高频次 <= k`
   - `窗口大小 - maxFreq` 表示需要替换的字符数
   - 如果超过 `k`，则需要收缩窗口
2. **maxFreq 维护**：
   - 不需要减小 `maxFreq`（只关心历史最大频次）
   - 因为我们寻找的是最长窗口，不需要减小的情况
3. **窗口收缩**：当不满足条件时，`left++`
4. **结果计算**：每次更新最大窗口长度

### 执行过程示例
对于 `"AABABBA"`, `k=1`：
```
right  char  频次        maxFreq  window  需替换  有效?  最大长度
0      A     A:1         1        1       0       ✓      1
1      A     A:2         2        2       0       ✓      2
2      B     A:2,B:1     2        3       1       ✓      3
3      A     A:3,B:1     3        4       1       ✓      4
4      B     A:3,B:2     3        5       2       ×      
       → left++: A:2,B:2  3       4       1       ✓      4
5      B     A:2,B:3     3        5       2       ×
       → left++: A:1,B:3  3       4       1       ✓      4
6      A     A:2,B:3     3        5       2       ×
       → left++: A:2,B:2  3       4       1       ✓      4

结果: 4
```

### 复杂度分析
- **时间复杂度**：$O(n)$，每个字符最多被访问两次
- **空间复杂度**：$O(1)$，固定大小的字符频次数组（26个大写字母）

```java
class Solution {
    public int characterReplacement(String s, int k) {
        if (k == s.length())
            return s.length();
        
        int left = 0;
        int mxFreq = 0;          // 窗口内最高频次
        int windowLength = 0;    // 最大窗口长度
        int[] chars = new int[26];  // 26个大写字母的频次
        
        for (int right = 0; right < s.length(); right++) {
            char ch = s.charAt(right);
            chars[ch - 'A']++;  // 更新当前字符频次
            
            int window = right - left + 1;  // 当前窗口大小
            mxFreq = Math.max(mxFreq, chars[ch - 'A']);  // 更新最高频次
            
            // 如果需要替换的字符数 > k，收缩窗口
            if (window - mxFreq > k) {
                chars[s.charAt(left) - 'A']--;  // 移除左边界字符
                left++;
            }
            
            // 更新最大窗口长度
            windowLength = Math.max(windowLength, right - left + 1);
        }
        return windowLength;
    }
}
```

# 209. [Minimum Size Subarray Sum](https://leetcode.com/problems/minimum-size-subarray-sum/description/)

### 题目描述
给定一个正整数数组 `nums` 和一个正整数 `target`，找出数组中满足其和 `>= target` 的长度最小的连续子数组，返回其长度。如果不存在，返回 `0`。

例如：`target = 7`, `nums = [2,3,1,2,4,3]` → 输出 `2`（子数组 `[4,3]`）

### 核心思想
使用**滑动窗口**。右边界不断扩展增加和，当和 `>= target` 时，尝试收缩左边界寻找更小的窗口。

### 关键点
1. **两个指针**：
   - `left`：窗口左边界
   - `right`：窗口右边界（遍历整个数组）
2. **窗口扩展**：`right` 向右移动，`sum += nums[right]`
3. **窗口收缩**：当 `sum >= target` 时，`left` 向右移动，`sum -= nums[left]`
4. **记录最小值**：每次满足条件时更新 `minSubArray`
5. **特殊情况**：如果始终找不到，返回 `0`

### 执行过程示例
对于 `target=7`, `nums=[2,3,1,2,4,3]`：
```
right  nums[right]  sum  left  窗口      满足?  minSubArray
0      2            2    0     [2]       ×      ∞
1      3            5    0     [2,3]     ×      ∞
2      1            6    0     [2,3,1]   ×      ∞
3      2            8    0     [2,3,1,2] ✓      4
                    6    1     [3,1,2]   ×
4      4            10   1     [3,1,2,4] ✓      4
                    7    2     [1,2,4]   ✓      3
                    5    3     [2,4]     ×
5      3            8    3     [2,4,3]   ✓      3
                    7    4     [4,3]     ✓      2
                    3    5     [3]       ×

结果: 2
```

### 复杂度分析
- **时间复杂度**：$O(n)$，每个元素最多被访问两次
- **空间复杂度**：$O(1)$

```java
class Solution {
    public int minSubArrayLen(int target, int[] nums) {
        int left = 0;
        int sum = 0;
        int minSubArray = Integer.MAX_VALUE;  // 初始化为最大值

        for (int right = 0; right < nums.length; right++) {
            sum += nums[right];  // 扩展窗口，增加和

            // 当 sum >= target 时，尝试收缩窗口
            while (sum >= target) {
                minSubArray = Math.min(minSubArray, right - left + 1);  // 更新最小长度
                sum -= nums[left];  // 收缩窗口，减小和
                left++;
            }
        }

        // 如果 minSubArray 没有更新，说明不存在符合条件的子数组
        return minSubArray == Integer.MAX_VALUE ? 0 : minSubArray;
    }
}
```

# 1004. [Max Consecutive Ones III](https://leetcode.com/problems/max-consecutive-ones-iii/description/)

### 题目描述
给定一个二进制数组 `nums` 和一个整数 `k`，最多可以将 `k` 个 `0` 翻转为 `1`。返回数组中连续 `1` 的最大个数。

例如：`nums = [1,1,1,0,0,0,1,1,1,1,0]`, `k = 2` → 输出 `6`（将两个 `0` 翻转，得到 `[1,1,1,0,0,1,1,1,1,1,1]`）

### 核心思想
使用**滑动窗口**。维护窗口内 `0` 的个数，当 `0` 的个数超过 `k` 时，收缩左边界。

### 关键点
1. **计数器**：`count` 记录窗口内 `0` 的个数
2. **窗口维护**：
   - 当遇到 `0` 时，`count++`
   - 当 `count > k` 时，收缩左边界直到 `count <= k`
3. **更新最大值**：每次更新 `max = max(max, right - left + 1)`
4. **核心逻辑**：窗口内最多包含 `k` 个 `0`，这样可以将它们都翻转为 `1`

### 执行过程示例
对于 `nums=[1,1,1,0,0,0,1,1,1,1,0]`, `k=2`：
```
right  val  count  left  窗口             有效?  长度  max
0      1    0      0     [1]             ✓      1     1
1      1    0      0     [1,1]           ✓      2     2
2      1    0      0     [1,1,1]         ✓      3     3
3      0    1      0     [1,1,1,0]       ✓      4     4
4      0    2      0     [1,1,1,0,0]     ✓      5     5
5      0    3      0     [1,1,1,0,0,0]   ×      -     5
       -    2      1     [1,1,0,0,0]     ✓      5     5
6      1    2      1     [1,1,0,0,0,1]   ✓      6     6
7      1    2      1     [1,1,0,0,0,1,1] ✓      7     7
...
结果: 6 (翻转两个0后得到连续1)
```

### 复杂度分析
- **时间复杂度**：$O(n)$，每个元素最多被访问两次
- **空间复杂度**：$O(1)$

```java
class Solution {
    public int longestOnes(int[] nums, int k) {
        int max = 0;      // 最大长度
        int left = 0;     // 左边界
        int count = 0;    // 窗口内 0 的个数
        
        for (int right = 0; right < nums.length; right++) {
            // 遇到 0 时，计数器增加
            if (nums[right] == 0) {
                count++;
            }

            // 当窗口内 0 的个数超过 k 时，收缩窗口
            while (count > k) {
                if (nums[left] == 0) {
                    count--;  // 移除左边界的 0
                }
                left++;
            }

            // 更新最大长度
            max = Math.max(max, right - left + 1);
        }
        return max;
    }
}
```

# 1208. Get Equal Substrings Within Budget

### 题目描述
给定两个字符串 `s` 和 `t`，以及一个最大成本 `maxCost`。可以将 `s` 中的任意字符更改为其他字符，每次更改的成本是 `|s[i] - t[i]|`。返回在不超过 `maxCost` 的情况下，能使 `s` 和 `t` 相等的子串的最大长度。

例如：`s = "abcd"`, `t = "bcdf"`, `maxCost = 3` → 输出 `3`
解释：将 `s[0]` 改为 `t[0]` 需要成本 `|'a'-'b'|=1`，将 `s[1]` 改为 `t[1]` 需要成本 `0`，将 `s[2]` 改为 `t[2]` 需要成本 `2`，总成本 `3`。

### 核心思想
使用**滑动窗口**。维护窗口内的总成本，当总成本超过 `maxCost` 时，收缩左边界。

### 关键点
1. **成本计算**：每个位置的成本是 `Math.abs(s.charAt(i) - t.charAt(i))`
2. **窗口维护**：
   - 右边界扩展，增加总成本
   - 左边界收缩，减少总成本
3. **窗口有效性**：当 `totalCost <= maxCost` 时，窗口有效
4. **更新最大长度**：每次窗口有效时更新最大值

### 执行过程示例
对于 `s="abcd"`, `t="bcdf"`, `maxCost=3`：
```
i   s[i]  t[i]  成本  累计成本  left  窗口      有效?  长度
0   a     b     1      1         0     [a]      ✓      1
1   b     c     1      2         0     [ab]     ✓      2
2   c     d     1      3         0     [abc]    ✓      3
3   d     f     2      5         0     [abcd]   ×      -
                       4         1     [bcd]    ×      -
                       3         2     [cd]     ✓      2

结果: 3
```

### 复杂度分析
- **时间复杂度**：$O(n)$，每个字符最多被访问两次
- **空间复杂度**：$O(1)$

```java
class Solution {
    public int equalSubstring(String s, String t, int maxCost) {
        int left = 0;
        int totalCost = 0;   // 窗口内的总成本
        int maxLength = 0;   // 最大长度
        
        for (int right = 0; right < s.length(); right++) {
            // 计算当前位置的成本
            int cost = Math.abs(s.charAt(right) - t.charAt(right));
            totalCost += cost;  // 扩展窗口
            
            // 当总成本超过 maxCost 时，收缩窗口
            while (totalCost > maxCost) {
                int leftCost = Math.abs(s.charAt(left) - t.charAt(left));
                totalCost -= leftCost;  // 移除左边界的成本
                left++;
            }
            
            // 更新最大长度
            maxLength = Math.max(maxLength, right - left + 1);
        }
        
        return maxLength;
    }
}
```

# 1695. [Maximum Erasure Value](https://leetcode.com/problems/maximum-erasure-value/)

### 题目描述
给定一个正整数数组 `nums`，找出数组中所有唯一元素的子数组的最大总和。如果擦除该子数组，可以得到的分数就是该子数组的总和。

例如：`nums = [4,2,4,5,6]` → 输出 `17`（子数组 `[2,4,5,6]`）

### 核心思想
使用**滑动窗口 + 哈希表**。维护一个不含重复元素的窗口，跟踪窗口内的总和，当遇到重复元素时，收缩左边界。

### 关键点
1. **哈希表**：`Set<Integer>` 用于检测重复元素
2. **窗口维护**：
   - 如果 `nums[right+1]` 不在集合中，扩展窗口
   - 否则收缩左边界直到移除重复元素
3. **累计和**：`sum` 跟踪当前窗口的总和
4. **更新最大值**：每次窗口变化时更新 `max`

### 执行过程示例
对于 `nums=[4,2,4,5,6]`：
```
right  val  set        sum  left  窗口      有效?  max
-1     -    {}         0    0     []        -      0
0      4    {4}        4    0     [4]       ✓      4
1      2    {4,2}      6    0     [4,2]     ✓      6
2      4    重复!     6    0     [4,2]     ×      6
            {2}        2    1     [2]       ✓      6
       4    {2,4}      6    1     [2,4]     ✓      6
3      5    {2,4,5}    11   1     [2,4,5]   ✓      11
4      6    {2,4,5,6}  17   1     [2,4,5,6] ✓      17

结果: 17
```

### 复杂度分析
- **时间复杂度**：$O(n)$，每个元素最多被访问两次
- **空间复杂度**：$O(n)$，哈希表存储

```java
import java.util.HashSet;
import java.util.Set;

class Solution {
    public int maximumUniqueSubarray(int[] nums) {
        int left = 0;
        int right = -1;
        int sum = 0;      // 当前窗口的总和
        int max = 0;      // 最大总和
        Set<Integer> set = new HashSet<>();  // 用于检测重复元素
        
        while (right + 1 < nums.length) {
            // 如果下一个元素不重复，扩展窗口
            if (!set.contains(nums[right + 1])) {
                right++;
                sum += nums[right];
                set.add(nums[right]);
            } else {
                // 遇到重复元素，收缩左边界
                sum -= nums[left];
                set.remove(nums[left]);
                left++;
            }
            
            // 更新最大总和
            max = Math.max(max, sum);
        }
        return max;
    }
}
```
