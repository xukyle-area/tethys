# LeetCode 1438: 绝对差不超过限制的最长连续子数组

## 题目描述
给你一个整数数组 `nums`，和一个表示限制的整数 `limit`，请你返回最长连续子数组的长度，该子数组中的任意两个元素之间的绝对差必须小于或者等于 `limit`。

## 核心思路

### 问题分析
- 需要找到最长的连续子数组，使得其中最大值与最小值的差不超过 `limit`
- 关键：需要**快速获取窗口内的最大值和最小值**
- 如果每次遍历窗口计算最值，时间复杂度会变成 O(n²)

### 解决方案：双单调队列 + 滑动窗口
- 使用**单调递减队列**维护窗口最大值
- 使用**单调递增队列**维护窗口最小值  
- 队列存储**索引**而非值，便于判断元素是否过期

## 算法实现

```java
import java.util.ArrayDeque;
import java.util.Deque;

class Solution {
    public int longestSubarray(int[] nums, int limit) {
        // 维护窗口最小值的单调递增队列
        Deque<Integer> minQueue = new ArrayDeque<>();
        // 维护窗口最大值的单调递减队列  
        Deque<Integer> maxQueue = new ArrayDeque<>();
        
        int result = 0;
        int left = 0;
        
        for (int right = 0; right < nums.length; right++) {
            // 维护最小值队列：移除所有大于当前元素的队尾元素
            while (!minQueue.isEmpty() && nums[minQueue.peekLast()] > nums[right]) {
                minQueue.pollLast();
            }
            minQueue.offerLast(right);
            
            // 维护最大值队列：移除所有小于当前元素的队尾元素
            while (!maxQueue.isEmpty() && nums[maxQueue.peekLast()] < nums[right]) {
                maxQueue.pollLast();
            }
            maxQueue.offerLast(right);
            
            // 收缩窗口：当最大值与最小值差超过limit时
            while (!maxQueue.isEmpty() && !minQueue.isEmpty() && 
                   nums[maxQueue.peekFirst()] - nums[minQueue.peekFirst()] > limit) {
                // 移除过期元素
                if (maxQueue.peekFirst() == left) {
                    maxQueue.pollFirst();
                }
                if (minQueue.peekFirst() == left) {
                    minQueue.pollFirst();
                }
                left++;
            }
            
            // 更新最大长度
            result = Math.max(result, right - left + 1);
        }
        
        return result;
    }
}
```

## 算法详解

### 1. 数据结构设计

**最小值队列 (minQueue)**
- 维护单调递增序列：`nums[queue[0]] ≤ nums[queue[1]] ≤ ...`
- 队头存储当前窗口最小值的索引

**最大值队列 (maxQueue)**  
- 维护单调递减序列：`nums[queue[0]] ≥ nums[queue[1]] ≥ ...`
- 队头存储当前窗口最大值的索引

### 2. 关键操作解析

#### 添加新元素（队尾操作）
```java
// 对于最小值队列：移除队尾所有大于新元素的值
while (!minQueue.isEmpty() && nums[minQueue.peekLast()] > nums[right]) {
    minQueue.pollLast();
}
```

**原理**：如果新元素更小，则队列中所有比它大的元素永远不可能成为最小值，可以直接删除。

#### 获取最值（队头操作）
```java
// 队头永远是当前窗口的最值
int windowMin = nums[minQueue.peekFirst()];
int windowMax = nums[maxQueue.peekFirst()];
```

#### 移除过期元素（队头操作）
```java
// 只有队头元素可能过期（因为它是最早进入的）
if (maxQueue.peekFirst() == left) {
    maxQueue.pollFirst();
}
```

### 3. 为什么必须存储索引？
如果只存储值，无法判断元素是否已经移出窗口：
```
nums = [5, 5, 5, 5], left = 2
如果队列只存值 [5]，无法知道这个5是哪个位置的元素
```

## 复杂度分析

- **时间复杂度：O(n)**
  - 每个元素最多进队一次，出队一次
  - 总共 2n 次队列操作

- **空间复杂度：O(n)**  
  - 最坏情况下，队列存储所有元素索引

## 执行示例

### 示例1：基础案例

**输入**：`nums = [8,2,4,7], limit = 4`

| 步骤 | right | 窗口 | maxQueue | minQueue | max-min | 动作 | 长度 |
|------|-------|------|----------|----------|---------|------|------|
| 1 | 0 | [8] | [0(8)] | [0(8)] | 0 | - | 1 |
| 2 | 1 | [8,2] | [0(8)] | [1(2)] | 6 > 4 | left++ | 1 |
| 3 | 2 | [2,4] | [2(4)] | [1(2)] | 2 ≤ 4 | - | 2 |
| 4 | 3 | [2,4,7] | [3(7)] | [1(2)] | 5 > 4 | left++ | 2 |

**结果**：2

### 示例2：递增序列

**输入**：`nums = [1,3,5,7,9], limit = 3`

| 步骤 | right | left | 窗口 | maxQueue | minQueue | max-min | 动作 | 长度 |
|------|-------|------|------|----------|----------|---------|------|------|
| 1 | 0 | 0 | [1] | [0(1)] | [0(1)] | 0 | - | 1 |
| 2 | 1 | 0 | [1,3] | [1(3)] | [0(1)] | 2 ≤ 3 | - | 2 |
| 3 | 2 | 0 | [1,3,5] | [2(5)] | [0(1)] | 4 > 3 | left++ | 2 |
| 4 | 2 | 1 | [3,5] | [2(5)] | [1(3)] | 2 ≤ 3 | - | 2 |
| 5 | 3 | 1 | [3,5,7] | [3(7)] | [1(3)] | 4 > 3 | left++ | 2 |
| 6 | 3 | 2 | [5,7] | [3(7)] | [2(5)] | 2 ≤ 3 | - | 2 |
| 7 | 4 | 2 | [5,7,9] | [4(9)] | [2(5)] | 4 > 3 | left++ | 2 |
| 8 | 4 | 3 | [7,9] | [4(9)] | [3(7)] | 2 ≤ 3 | - | 2 |

**结果**：2

### 示例3：复杂混合序列

**输入**：`nums = [10,1,2,4,7,2], limit = 5`

| 步骤 | right | left | 窗口 | maxQueue | minQueue | max-min | 动作 | 长度 |
|------|-------|------|------|----------|----------|---------|------|------|
| 1 | 0 | 0 | [10] | [0(10)] | [0(10)] | 0 | - | 1 |
| 2 | 1 | 0 | [10,1] | [0(10)] | [1(1)] | 9 > 5 | left++ | 1 |
| 3 | 1 | 1 | [1] | [1(1)] | [1(1)] | 0 | - | 1 |
| 4 | 2 | 1 | [1,2] | [2(2)] | [1(1)] | 1 ≤ 5 | - | 2 |
| 5 | 3 | 1 | [1,2,4] | [3(4)] | [1(1)] | 3 ≤ 5 | - | 3 |
| 6 | 4 | 1 | [1,2,4,7] | [4(7)] | [1(1)] | 6 > 5 | left++ | 3 |
| 7 | 4 | 2 | [2,4,7] | [4(7)] | [2(2)] | 5 ≤ 5 | - | 3 |
| 8 | 5 | 2 | [2,4,7,2] | [4(7)] | [2(2),5(2)] | 5 ≤ 5 | - | 4 |

**结果**：4

### 示例4：所有元素相同

**输入**：`nums = [4,4,4,4,4], limit = 2`

| 步骤 | right | left | 窗口 | maxQueue | minQueue | max-min | 长度 |
|------|-------|------|------|----------|----------|---------|------|
| 1 | 0 | 0 | [4] | [0(4)] | [0(4)] | 0 | 1 |
| 2 | 1 | 0 | [4,4] | [0(4)] | [0(4)] | 0 | 2 |
| 3 | 2 | 0 | [4,4,4] | [0(4)] | [0(4)] | 0 | 3 |
| 4 | 3 | 0 | [4,4,4,4] | [0(4)] | [0(4)] | 0 | 4 |
| 5 | 4 | 0 | [4,4,4,4,4] | [0(4)] | [0(4)] | 0 | 5 |

**结果**：5（整个数组）

### 示例5：单调队列维护过程详解

**输入**：`nums = [3,1,5,2,6], limit = 4`

#### 详细步骤分析

**Step 1: right=0, 添加元素3**
```
minQueue: [] → [0(3)]
maxQueue: [] → [0(3)]
窗口: [3], max-min = 0 ≤ 4 ✓
长度: 1
```

**Step 2: right=1, 添加元素1** 
```
minQueue维护:
- 比较: 3 > 1, 移除索引0 → []
- 添加索引1 → [1(1)]

maxQueue维护:  
- 比较: 3 > 1, 保留 → [0(3)]
- 添加索引1 → [0(3), 1(1)]

窗口: [3,1], max-min = 2 ≤ 4 ✓
长度: 2
```

**Step 3: right=2, 添加元素5**
```
minQueue维护:
- 比较: 1 < 5, 保留 → [1(1)]
- 添加索引2 → [1(1), 2(5)]

maxQueue维护:
- 比较: 1 < 5, 移除索引1 → [0(3)]  
- 比较: 3 < 5, 移除索引0 → []
- 添加索引2 → [2(5)]

窗口: [3,1,5], max-min = 4 ≤ 4 ✓
长度: 3
```

**Step 4: right=3, 添加元素2**
```
minQueue维护:
- 比较: 5 > 2, 移除索引2 → [1(1)]
- 添加索引3 → [1(1), 3(2)]

maxQueue维护:
- 比较: 5 > 2, 保留 → [2(5)]
- 添加索引3 → [2(5), 3(2)]

窗口: [3,1,5,2], max-min = 4 ≤ 4 ✓
长度: 4
```

**Step 5: right=4, 添加元素6**
```
minQueue维护:
- 比较: 2 < 6, 保留 → [1(1), 3(2)]
- 添加索引4 → [1(1), 3(2), 4(6)]

maxQueue维护:
- 比较: 2 < 6, 移除索引3 → [2(5)]
- 比较: 5 < 6, 移除索引2 → []
- 添加索引4 → [4(6)]

窗口: [3,1,5,2,6], max-min = 5 > 4 ❌
需要收缩窗口...

left从0移动到1: 窗口[1,5,2,6], max-min = 5 > 4 ❌
left从1移动到2: 窗口[5,2,6], max-min = 4 ≤ 4 ✓
长度: 3
```

**最终结果**：4

### 示例6：队列中多个数字的详细案例

**输入**：`nums = [5,1,3,5,10,7,4,9,2,8], limit = 6`

这个例子专门展示单调队列中包含**多个元素**的情况：

#### Step 1-4: 建立初始窗口
```
Step 1: 添加5  → minQueue=[0(5)], maxQueue=[0(5)]
Step 2: 添加1  → minQueue=[1(1)], maxQueue=[0(5),1(1)]  
Step 3: 添加3  → minQueue=[1(1),2(3)], maxQueue=[0(5),2(3)]
Step 4: 添加5  → minQueue=[1(1),2(3)], maxQueue=[0(5),3(5)]
窗口: [5,1,3,5], max-min = 4 ≤ 6 ✓
```

**队列状态分析**：
- `maxQueue=[0(5),3(5)]`：包含两个5，队头是索引0的5（更早），索引3的5在后面作为候选
- `minQueue=[1(1),2(3)]`：递增序列，1是当前最小值，3是候选

#### Step 5: 添加10 - 关键的多元素维护
```
添加10时的队列变化：

maxQueue维护：
- 当前：[0(5), 3(5)]  
- 10 > 5，移除索引3 → [0(5)]
- 10 > 5，移除索引0 → []
- 添加索引4 → [4(10)]

minQueue维护：
- 当前：[1(1), 2(3)]
- 10 > 3，保留 → [1(1), 2(3)]  
- 添加索引4 → [1(1), 2(3), 4(10)]

结果：minQueue=[1(1),2(3),4(10)], maxQueue=[4(10)]
窗口: [5,1,3,5,10], max-min = 9 > 6 ❌
```

#### Step 6: 窗口收缩后添加7
```
收缩到窗口[1,3,5,10]后，添加7：

maxQueue维护：
- 当前：[4(10)]
- 7 < 10，保留 → [4(10)]
- 添加索引5 → [4(10), 5(7)]

minQueue维护：  
- 当前：[1(1), 2(3), 4(10)]
- 7 < 10，移除索引4 → [1(1), 2(3)]
- 添加索引5 → [1(1), 2(3), 5(7)]

结果：minQueue=[1(1),2(3),5(7)], maxQueue=[4(10),5(7)]
```

#### Step 7: 继续添加4
```
添加4时：

maxQueue维护：
- 当前：[4(10), 5(7)]  
- 4 < 7，保留 → [4(10), 5(7)]
- 添加索引6 → [4(10), 5(7), 6(4)]

minQueue维护：
- 当前：[1(1), 2(3), 5(7)]
- 4 < 7，移除索引5 → [1(1), 2(3)]
- 4 > 3，保留 → [1(1), 2(3)]  
- 添加索引6 → [1(1), 2(3), 6(4)]
```

#### 关键队列状态总结表

| 操作 | minQueue状态 | maxQueue状态 | 说明 |
|------|-------------|-------------|------|
| 添加1,3,5 | [1(1), 2(3)] | [0(5), 3(5)] | 两个队列都有多个元素 |
| 添加10 | [1(1), 2(3), 4(10)] | [4(10)] | minQueue有3个元素 |
| 添加7 | [1(1), 2(3), 5(7)] | [4(10), 5(7)] | 两队列都保持多元素 |
| 添加4 | [1(1), 2(3), 6(4)] | [4(10), 5(7), 6(4)] | maxQueue有3个递减元素 |

### 多元素队列的核心理解

#### 1. 单调序列的力量
```
maxQueue = [4(10), 5(7), 6(4)]  
表示：索引4的10 > 索引5的7 > 索引6的4
```
**含义**：当索引4的10过期时，索引5的7自动成为新的最大值

#### 2. 候选备选机制  
```
minQueue = [1(1), 2(3), 6(4)]
表示：当前最小值是1，但3和4都是潜在候选
```
**含义**：如果1过期，3成为新最小值；如果3也过期，4成为最小值

#### 3. 时间+空间的双重排序
- **时间维度**：队头到队尾按加入时间排序
- **空间维度**：队头到队尾按单调性排序
- **双重保证**：既能O(1)获取最值，又能正确处理过期

### 关键观察

通过这些示例可以发现：
1. **单调队列自动维护**：不需要手动排序，通过比较自动保持单调性
2. **索引vs值**：队列存储索引，通过索引获取对应的值进行比较  
3. **过期处理**：只有队头可能过期，因为它代表最早进入的元素
4. **效率优势**：每个元素最多进出队列一次，总体O(n)复杂度

## 核心理解

### 为什么"添加到队尾，获取用队头"？

这是单调队列的核心设计：

1. **队列按时间顺序**：队头是最早进入的，队尾是最新进入的
2. **单调性保证最值**：由于维护了单调性，队头必然是当前窗口的最值
3. **新元素影响队尾**：新元素可能淘汰一些旧的"候选值"
4. **过期元素只影响队头**：最老的元素总是在队头，过期时首先影响队头

### 直观理解
- **队尾** = 新员工入职口（负责清理不合格候选，然后新员工入队）
- **队头** = 当前冠军位置（如果冠军退休离开窗口，换下一个候选上位）

## 算法模板

这是**双单调队列 + 滑动窗口**的经典模板，适用于：
- 求滑动窗口中的最大值最小值
- 可变窗口的约束问题  
- 连续区间合法性判断

```java
// 双单调队列模板
Deque<Integer> minQueue = new ArrayDeque<>();  // 维护最小值
Deque<Integer> maxQueue = new ArrayDeque<>();  // 维护最大值

for (int right = 0; right < n; right++) {
    // 维护单调性
    while (!minQueue.isEmpty() && nums[minQueue.peekLast()] >= nums[right]) {
        minQueue.pollLast();
    }
    // 类似处理maxQueue...
    
    // 收缩窗口
    while (condition_not_satisfied) {
        if (!minQueue.isEmpty() && minQueue.peekFirst() == left) {
            minQueue.pollFirst();
        }
        // 类似处理maxQueue...
        left++;
    }
    
    // 更新结果
    result = Math.max(result, right - left + 1);
}
```

## 相关题目

这道题是**单调队列 + 滑动窗口**的经典应用，相似题目包括：
- [239. 滑动窗口最大值](https://leetcode.com/problems/sliding-window-maximum/)
- [862. 和至少为 K 的最短子数组](https://leetcode.com/problems/shortest-subarray-with-sum-at-least-k/)  
- [1499. 满足不等式的最大值](https://leetcode.com/problems/max-value-of-equation/)

## 总结

这道题的核心是理解**单调队列的两端操作**：
- **队尾**：维护单调性，处理新元素
- **队头**：获取最值，处理过期元素

掌握了这个模式，能够解决大多数滑动窗口最值问题。从难度上来说，这道题确实更接近 Hard 级别，需要熟练掌握单调队列这一高级数据结构。

> **难度分析**：虽然标记为 Medium，但需要掌握单调队列这一高级数据结构，实际难度更接近 Hard 级别。这类题目的 AC 率通常只有 20-35%，远低于普通中等题的 40-60%。